### Learning "Algorithm in Go" 

---

### 1. Iterative Structures (using loops / iterators)

**ch01 Arrays**

* **Arrays — basic operations:** search, insertion, deletion, and shifting.
* **Two Pointers:** efficient traversal of sorted arrays, searching for pairs and triplets.
* **Strings:** working with sequences of characters as arrays.
* **Sliding Window:** analysis of subarrays with fixed or variable length.
* **Intervals:** merging, intersection, and sorting of ranges.

---

### 2. Recursion (task recursion + matrices)

**ch02 matrices**

* **Matrices:** two-dimensional arrays — traversal, diagonals, rotation (using loops / iterators).
* **Matrices:** Recursion (task recursion + matrices)

The basic principle: divide a problem into smaller subproblems of the same type.
Applied in tree and graph traversal, as well as in backtracking search.

**Backtracking Search** — recursive enumeration of all possible options with a step-back when an invalid state is reached.
Examples: Sudoku solver, permutations, combinations generation, N-Queens problem.

---

### Stack and Queue

* **Stack (LIFO structure):** used in expression evaluation, reverse traversal, recursion.
* **Queue (FIFO structure):** used in simulations, BFS traversal, and data streams.
* **Monotonic Queue:** maintains elements in ascending/descending order; used for finding maximums in sliding windows.

---

### Linked List

A structure where each element references the next one.
Tasks: reversal, node deletion, finding the middle node, detecting a cycle.

---

### Hash Tables

Associative arrays providing fast access by key.
Used for searching, counting frequencies, and removing duplicates.

*All of the above structures operate through iteration — traversal of elements using iterators, loops, or pointers.*

---

### 2. Recursive Structures (using function calls)

**Recursion**
The core principle: divide a problem into subproblems of the same type.
Applied in traversing trees, graphs, and solving problems with backtracking.

**Backtracking**
A recursive enumeration of all possible configurations with returning one step back upon an invalid choice.
Examples: Sudoku, permutations, combinations generation, N-Queens.

---

### 3. Trees

Hierarchical data structures, usually traversed recursively.

* **Binary Tree:** each node has up to two children.
* **Binary Search Tree (BST):** left subtree ≤ node < right subtree.
* **Binary Heap:** a priority structure used for sorting and priority queues.
* **Prefix Tree (Trie):** used for storing strings, autocomplete, and dictionaries.

---

### 4. Graphs

Data structures representing relationships between vertices; traversed recursively or via stacks/queues.

* **Depth-First Search (DFS):** recursive traversal, exploring as deep as possible before backtracking.
* **Breadth-First Search (BFS):** iterative level-by-level traversal using a queue.

---

### 5. Sorting

Bubble, Selection, Insertion, Merge, Quick, and other algorithms.
Some (Merge Sort, Quick Sort) are recursive; others (Bubble, Insertion) are iterative.

---

### 6. Binary Search

Efficient method for finding an element in a sorted array.
Can be implemented either iteratively or recursively.

*These sections employ recursion — calling a function within itself to traverse or solve a problem.*

---

### 7. Dynamic Programming (DP)

A method for solving complex problems by breaking them into overlapping subproblems and storing intermediate results.

* **Memoization:** recursive approach with caching of results.
* **Tabulation:** iterative approach, filling a DP table from bottom to top.

---

###  **1. Итерационные структуры (через цикл / итератор)**

#### ch01 Массивы (Arrays)

* **Массивы** — базовые операции: поиск, вставка, удаление, сдвиги.
* **Два указателя (Two Pointers)** — эффективный обход отсортированных массивов, поиск пар и троек.
* **Строки** — работа с последовательностями символов как с массивами.
* **Матрицы (Matrices)** — двумерные массивы, обход, диагонали, вращение.
* **Скользящее окно (Sliding Window)** — анализ подмассивов фиксированной или переменной длины.
* **Интервалы (Intervals)** — объединение, пересечение и сортировка диапазонов.

---

#### ch02 Рекурсия

* Базовый принцип: делим задачу на подзадачи того же типа. Применяется при обходе деревьев, графов и при поиске решений с откатами.

> нужно реализовать в этой части следующее:
> поиск с возвратом (Backtracking) - рекурсивный перебор всех вариантов с возвратом на шаг назад при ошибке.
(Sudoku, перестановки, генерация комбинаций, N-ферзей.)

---

#### Стек и очередь (Stack & Queue)

* **Стек (Stack)** — LIFO-структура, используется для выражений, обратного обхода, рекурсии.
* **Очередь (Queue)** — FIFO-структура, применяется в симуляциях, BFS и потоках данных.
* **Монотонная очередь** — поддерживает элементы в порядке возрастания/убывания, используется для поиска максимумов в окнах.

---
#### Связный список (Linked List)

* Структура, где каждый элемент ссылается на следующий.
* Задачи: реверс, удаление узла, поиск середины, цикл в списке.

---
####  Хэш-таблицы (Hash Tables)

* Ассоциативные массивы для быстрого доступа по ключу.
* Применяются для поиска, подсчёта частоты, устранения дубликатов.

---

> Все выше структуры работают **через итерацию** — перебор элементов (итераторы, циклы, указатели).

---

###  **2. Рекурсивные структуры (через вызовы функций)**

####  **Рекурсия**

* Базовый принцип: делим задачу на подзадачи того же типа.
* Применяется при обходе деревьев, графов и при поиске решений с откатами.

---

####  Поиск с возвратом (Backtracking)
- Поиск с возвратом (Backtracking) - это рекурсивный перебор всех вариантов с возвратом на шаг назад при ошибке.
- Примеры: Sudoku, перестановки, генерация комбинаций, N-ферзей.


---

###  **3. Деревья (Trees)**

Иерархические структуры данных. Обход чаще **рекурсивный**.

* **Двоичное дерево (Binary Tree)** — каждый узел имеет до двух потомков.
* **Двоичное дерево поиска (BST)** — левое поддерево ≤ узел < правое поддерево.
* **Двоичная куча (Heap)** — приоритетная структура для сортировки и очередей.
* **Префиксное дерево (Trie)** — хранение строк, используется в автодополнении и словарях.

---

###  **4. Графы (Graphs)**

Связи между вершинами; обход обычно рекурсивный или с очередями/стеками.

* **Поиск в глубину (DFS)** — рекурсивный обход, углубление до конца ветви.
* **Поиск в ширину (BFS)** — итерационный обход уровня за уровнем с очередью.

---

###  **5. Сортировки (Sorting)**

* Пузырьковая, выбором, вставками, слиянием, быстрая и другие.
* Некоторые (MergeSort, QuickSort) — **рекурсивные**, другие (Bubble, Insertion) — **итерационные**.

---

###  **6. Двоичный поиск (Binary Search)**

* Эффективный поиск элемента в отсортированном массиве.
* Может быть **итерационным** или **рекурсивным**, в зависимости от реализации.

> Эти разделы используют **рекурсию** — вызов функции самой себя для обхода или решения задачи.

---

###  **7. Динамическое программирование (Dynamic Programming)**

Метод решения сложных задач путём разбиения на подзадачи и запоминания результатов.

* **Мемоизация (Memoization)** — рекурсивный подход с кэшированием.
* **Табуляция (Tabulation)** — итерационный подход, заполнение таблицы снизу вверх.


---

```
Массивы (Arrays):

| №  | Название задачи                             | Описание                                                                                                    | Сложность  | Тип / Подход                              |
| -- | ------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ---------- | ------------------------------------------|
| 1  | **Максимальная прибыль (одна сделка)**      | Дан массив цен акций. Найти максимальную прибыль, которую можно получить от одной покупки и одной продажи.  | Лёгкая  | Массивы, Два указателя                       |
| 2  | **Анализ баланса (Кадане)**                 | Дан массив ежедневных изменений баланса счёта. Найти максимальную сумму дохода за любой непрерывный период. | Средняя | Массивы, Алгоритм Кадане                     |
| 3  | **Сортировка по категориям (Dutch Flag)**   | Отсортировать массив заказов с приоритетами 0–1–2 (высокие, средние, низкие).                               | Средняя | Сортировка, Два указателя                    |
| 4  | **Сдвиг данных (Ротация логов)**            | Повернуть массив логов на K позиций вправо.                                                                 | Лёгкая  | Массивы, Ротация                             |
| 5  | **Пропущенный платёж**                      | Найти единственный пропущенный платёж в диапазоне [1, N].                                                   | Лёгкая  | Арифметика, XOR или сумма                    |
| 6  | **Единственный сотрудник**                  | Найти ID сотрудника, который встречается один раз, остальные — по два раза.                                 | Лёгкая  | XOR, Побитовые операции                      |
| 7  | **Продукт конкурентов**                     | Для каждого элемента i вычислить произведение всех остальных (без деления).                                 | Средняя | Массивы, Префикс/Постфикс произведения       |
| 8  | **Максимальная последовательная убыль цен** | Найти максимальное количество последовательных дней падения цены.                                           | Лёгкая  | Массивы, Подсчёт серий                       |
| 9  | **Сдвиг неактивных пользователей**          | Переместить все 0 (неактивные) в конец массива, сохранив порядок активных.                                  | Лёгкая  | Массивы, Два указателя                       |
| 10 | **Рейтинг популярности товара**             | Найти 3 самые часто встречающиеся оценки (от 1 до 5).                                                       | Средняя | Хеш-таблицы, Частотный анализ                |
| 11 | **Баланс транзакций**                       | Найти день минимального накопленного баланса.                                                               | Средняя | Префиксные суммы, Анализ                     |
| 12 | **Проверка контрольной суммы (ISBN)**       | Проверить корректность контрольной суммы ISBN-10.                                                           | Лёгкая  | Арифметика, Цикл, Проверка контрольной суммы |
| 13 | **Поиск пиковой нагрузки**                  | Найти пиковый элемент в массиве потребления энергии.                                                        | Средняя | Двоичный поиск, Локальный максимум           |
| 14 | **Самая длинная серия побед/поражений**     | Найти длину самой длинной последовательности одинаковых результатов.                                        | Лёгкая  | Массивы, Подсчёт серий                       |
| 15 | **Проверка уникальности ID**                | Проверить, содержит ли массив ID клиентов дубликаты.                                                        | Лёгкая  | Хеш-таблицы, Множества                       |


Два указателя (Two Pointers):

|  № | Название задачи                                     | Описание                                                                                                                                      |  Сложность | Тип / Подход                                                 |
| -: | --------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- | :--------: | -------------------------------------------------------------|
|  1 | **Целевая сумма инвестиций**                        | В отсортированном списке доходностей найти две доходности, сумма которых максимально близка к целевому годовому доходу.                       | Средняя | Массивы, Два указателя (левый/правый), жадный                   |
|  2 | **Квадраты отсортированных значений**               | Дан массив изменений цен (могут быть отрицательными). Вернуть массив квадратов этих изменений, отсортированный по возрастанию.                | Лёгкая  | Массивы, Два указателя (с краёв → внутрь)                       |
|  3 | **Удаление дубликатов (Склад)**                     | Дан отсортированный список инвентарных номеров. Удалить дубликаты на месте, чтобы каждый номер остался только один раз.                       | Лёгкая  | Массивы, Два указателя (in-place)                               |
|  4 | **Захват воды (Счётчик)**                           | Дан массив высот стендов. Вычислить, сколько жидкости может быть захвачено между стендами.                                                    | Сложная | Массивы, Два указателя (лев/право) или префиксные массивы       |
|  5 | **Сортировка чёт/нечёт (Чётность ID)**              | Разбить список ID так, чтобы сначала шли чётные ID, а потом нечётные, сохраняя относительный порядок внутри групп.                            | Средняя | Массивы, Стабильная перестановка (очередь/двойной проход)       |
|  6 | **Сумма трёх компонентов**                          | Найти все уникальные тройки чисел, сумма которых равна целевому значению.                                                                     | Средняя | Сортировка + Два указателя (три-пointers)                       |
|  7 | **Обратный порядок регионов**                       | Развернуть только гласные (или отмеченные символы) в строке названия региона, не меняя остальные символы.                                     | Лёгкая  | Строки, Два указателя (симметрично)                             |
|  8 | **Удаление старых версий**                          | Удалить все вхождения заданного значения из массива на месте.                                                                                 | Лёгкая  | Массивы, Два указателя (write index)                            |
|  9 | **Сжатие данных**                                   | Сжать строку повторяющихся символов: `"AAAAB"` → `"4A1B"`.                                                                                    | Средняя | Строки, Два указателя / подсчёт серий (in-place)                |
| 10 | **Поиск медианы двух отсортированных баз данных**   | Найти медиану двух отсортированных массивов без их фактического объединения.                                                                  | Сложная | Двоичный поиск по разбиению, O(log min(n,m))                    |
| 11 | **Парковка (Two-Side Matching)**                    | Найти максимальное количество автомобилей, которые можно поставить на парковку, используя отсортированные списки размеров мест и автомобилей. | Средняя | Сортировка + Два указателя (жадный матчинг)                     |
| 12 | **Оптимизация долга/актива**                        | Найти пары (должник, кредитор) с минимальной разницей, чтобы частично/полностью сбалансировать.                                               | Средняя | Сортировка + Два указателя (жадный подбор)                      |
| 13 | **Корректировка палиндрома**                        | Проверить, является ли строка палиндромом, игнорируя пробелы и пунктуацию.                                                                    | Лёгкая  | Строки, Два указателя (игнорирование не-алф/циф)                |
| 14 | **Нахождение пары с близкой суммой**                | В отсортированном массиве найти пару, сумма которой наиболее близка к целевому значению.                                                      | Средняя | Массивы, Два указателя (лев/право)                              |
| 15 | **Разделение положительных/отрицательных значений** | Переставить массив так, чтобы все отрицательные числа шли перед положительными.                                                               | Лёгкая  | Массивы, Два указателя (partition), можно стабильно/нестабильно |


Строки (Strings):

| №  | Название задачи                                   | Описание                                                                                        | Сложность  | Тип / Подход                         |
| -- | ------------------------------------------------- | ----------------------------------------------------------------------------------------------- | ---------- | -------------------------------------|
| 1  | **Разворот слов в адресе**                        | Развернуть порядок слов в строке почтового адреса.                                              | Лёгкая  | Строки, Разделение и объединение        |
| 2  | **Проверка анаграмм (Кодовые слова)**             | Проверить, являются ли две строки анаграммами друг друга.                                       | Лёгкая  | Строки, Сортировка или счётчик символов |
| 3  | **Самый длинный общий префикс (Файлы)**           | Найти самую длинную общую часть (префикс) в массиве имён файлов или URL.                        | Лёгкая  | Строки, Итерация по символам            |
| 4  | **Проверка скобок (Код/Конфиг)**                  | Проверить, правильно ли расставлены и закрыты скобки `(), [], {}` в строке.                     | Средняя | Стек, Строки                            |
| 5  | **Преобразование в целое число (Парсинг)**        | Реализовать функцию, которая преобразует строку в целое число (с учётом знаков и переполнения). | Средняя | Парсинг, Строки, Проверка диапазона     |
| 6  | **Проверка изоморфных SKU**                       | Проверить, имеют ли два артикула одинаковую структурную форму (изоморфны ли они).               | Средняя | Хеш-таблицы, Отображения                |
| 7  | **Шифр Цезаря (Rot13)**                           | Реализовать шифр Цезаря — простое смещение букв алфавита.                                       | Лёгкая  | Строки, Шифрование                      |
| 8  | **Самый часто повторяющийся символ (Статистика)** | Найти символ, который встречается чаще всего в тексте.                                          | Лёгкая  | Частотный анализ, Хеш-таблицы           |
| 9  | **Проверка на палиндром-перестановку**            | Проверить, можно ли переставить символы строки, чтобы получился палиндром.                      | Средняя | Частотный анализ, Строки                |
| 10 | **Сокращение пути (Unix-стиль)**                  | Упростить путь файловой системы (`/a/./b/../c → /c`).                                           | Средняя | Стек, Строки                            |
| 11 | **Преобразование Excel столбца**                  | Преобразовать буквенное название столбца Excel в его числовой индекс.                           | Лёгкая  | Математика, Строки                      |
| 12 | **Валидация IP-адреса**                           | Проверить, является ли строка корректным IPv4-адресом.                                          | Средняя | Парсинг, Проверка диапазонов            |
| 13 | **Парсинг CSV**                                   | Разбить CSV-строку на поля, учитывая кавычки и запятые.                                         | Сложная | Парсинг, Автомат состояний              |
| 14 | **Форматирование валюты**                         | Сформировать строку с валютным форматом — разделители тысяч и знак валюты.                      | Лёгкая  | Форматирование, Строки                  |
| 15 | **Кодирование URL**                               | Заменить пробелы в строке на `%20` для корректного URL.                                         | Лёгкая  | Строки, Замена символов                 |


Матрицы (Matrices 2D - только итерация, без рекурсии): 

|  № | Название задачи                                 | Краткое описание                                                                        |  Сложность | Тип / Подход                               |
| -: | ----------------------------------------------- | ----------------------------------------------------------------------------- --------: | -------------------------------------------|
|  1 | **Спиральный обход склада**                     | Обойти матрицу по спирали и вернуть все элементы в порядке обхода.                      | Средняя | Границы + 4 направления                     |
|  2 | **Поворот изображения (90°)**                   | Повернуть квадратную матрицу на 90° по часовой стрелке.                                 | Средняя | Транспонирование + реверс строк              |
|  3 | **Установка нулей (Распространение ошибки)**    | Если элемент равен 0 — обнулить всю строку и столбец.                                   | Средняя | Первая строка/столбец как флаги              |
|  4 | **Проход по диагоналям (Анализ данных)**        | Вывести элементы матрицы по диагоналям (по сумме индексов).                             | Лёгкая  | Вложенные циклы, `i+j` как ключ              |
|  5 | **Тепловая карта (Усреднение)**                 | Каждая ячейка = среднее соседей в 3×3 окне.                                             | Лёгкая  | Вложенные циклы, суммирование по окрестности |
|  6 | **Проверка судоку**                             | Проверить, что в 9×9 нет повторов в строках, столбцах и блоках.                         | Лёгкая  | Итерация + множества / массивы               |
|  7 | **Самая большая область 1 (через гистограмму)** | Найти наибольший прямоугольник из 1 (через преобразование в гистограммы).               | Сложная | Итерация + стек для каждой строки            |
|  8 | **Зеркальное отражение**                        | Отразить матрицу по вертикали (по оси Y).                                               | Лёгкая  | Реверс элементов в строках                   |
|  9 | **Транспонирование не квадратной матрицы**      | Поменять местами строки и столбцы (m×n → n×m).                                          | Лёгкая  | Двойной цикл                                 |
| 10 | **Сумма подматрицы (Финансовый отчёт)**         | Вернуть сумму элементов подматрицы [r1,c1,r2,c2].                                       | Средняя | Префиксные суммы 2D                          |
| 11 | **Поворот на 180° и 270°**                      | Реализовать общий поворот на 90°, 180°, 270°.                                           | Лёгкая  | Комбинация транспонирования и реверса        |
| 12 | **Ротация колец (Циклический сдвиг слоёв)**     | Сдвинуть элементы матрицы по кольцам.                                                   | Сложная | Послойная итерация и перестановка            |
| 13 | **Проверка симметрии матрицы**                  | Проверить, что `matrix[i][j] == matrix[j][i]`.                                          | Лёгкая  | Двойной цикл сравнения                       |
| 14 | **Сжатие данных (RLE 2D)**                      | Сжать матрицу, записав повторяющиеся элементы с количеством.                            | Сложная | Линейная итерация по строкам и столбцам      |
| 15 | **Замена диагоналей**                           | Поменять местами главную и побочную диагональ квадратной матрицы.                       | Лёгкая  | Итерация по индексам диагоналей              |
| 16 | **Сумма строк и столбцов**                      | Посчитать сумму каждой строки и каждого столбца в матрице.                              | Лёгкая  | Два вложенных цикла                          |
| 17 | **Транспонирование без доп. памяти**            | Транспонировать квадратную матрицу in-place.                                            | Средняя | Обмен `matrix[i][j]` и `matrix[j][i]`        |
| 18 | **Поиск максимального элемента**                | Найти максимальный элемент и его координаты.                                            | Лёгкая  | Итерация с хранением максимума               |
| 19 | **Подсчёт четных и нечётных**                   | Посчитать количество чётных и нечётных чисел в матрице.                                 | Лёгкая  | Вложенные циклы + условия                    |
| 20 | **Сдвиг строк вправо**                          | Сдвинуть все строки на k позиций вправо (циклически).                                   | Средняя | Итерация по строкам и индексная арифметика   |
| 21 | **Сдвиг столбцов вниз**                         | Сдвинуть все столбцы на k позиций вниз (циклически).                                    | Средняя | Итерация по столбцам и индексная арифметика  |
| 22 | **Замена отрицательных на 0**                   | В матрице заменить все отрицательные элементы на 0.                                     | Лёгкая  | Вложенные циклы + проверка условия           |
| 23 | **Умножение матрицы на число**                  | Умножить все элементы матрицы на константу.                                             | Лёгкая  | Два вложенных цикла                          |
| 24 | **Сумма диагоналей**                            | Найти сумму главной и побочной диагоналей.                                              | Лёгкая  | Итерация по индексам с формулой для диагонали|
| 25 | **Обратный обход матрицы**                      | Пройти матрицу в обратном порядке (снизу вверх, справа налево).                         | Лёгкая  | Два вложенных цикла с обратными индексами    |
| 26 | **Сложение матриц**                             | Даны две матрицы `A` и `B` одинакового размера. Вернуть `C = A + B`.                    | Лёгкая  | Вложенные циклы, поэлементное сложение       |
| 27 | **Вычитание матриц**                            | Даны `A` и `B`. Вернуть `C = A - B`. Проверить размеры.                                 | Лёгкая  | Проверка размерности + поэлементное вычитание|
| 28 | **Умножение матрицы на скаляр**                 | Умножить все элементы матрицы на число `k`.                                             | Лёгкая  | Двойной цикл, `matrix[i][j] *= k`            |
| 29 | **Умножение матриц (A × B)**                    | Даны `A` (m×p) и `B` (p×n). Вернуть `C = A × B`.                                        | Средняя | Три вложенных цикла, формула `C[i][j] += ...`|
| 30 | **Возведение матрицы в степень**                | Дана квадратная матрица `A`. Найти `A^n` (n ≥ 0).                                       | Средняя | Рекурсия или цикл с умножением матриц        |
| 31 | **Определитель 2×2 и 3×3**                      | Вычислить определитель квадратной матрицы (только 2×2 и 3×3).                           | Лёгкая  | Формулы: `ad-bc` и правило Саррюса           |
| 32 | **След матрицы (Trace)**                        | Найти сумму элементов главной диагонали.                                                | Лёгкая  | Цикл по `i`, `sum += matrix[i][i]`           |
| 33 | **Проверка диагональной матрицы**               | Матрица диагональная, если все элементы вне главной диагонали — нули.                   | Лёгкая  | Проверка `matrix[i][j] == 0` при `i != j`     |
| 34 | **Проверка единичной матрицы**                  | Матрица единичная: `1` на диагонали, `0` везде.                                         | Лёгкая  | Проверка `matrix[i][j] == (i==j ? 1 : 0)`     |
| 35 | **Сумма всех элементов матрицы**                | Найти сумму всех элементов `A`.                                                         | Лёгкая  | Двойной цикл, аккумулятор                    |
| 36 | **Сложение векторов**                           | Даны два вектора `a` и `b` одинаковой длины. Вернуть `c = a + b`.                       | Лёгкая  | Поэлементное сложение                        |
| 37 | **Вычитание векторов**                          | Вернуть `c = a - b`. Проверить длину.                                                   | Лёгкая  | Поэлементное вычитание                       |
| 38 | **Умножение вектора на скаляр**                 | Умножить все компоненты вектора на `k`.                                                 | Лёгкая  | `v[i] *= k`                                  |
| 39 | **Скалярное произведение (dot product)**        | `a · b = Σ a[i]*b[i]`.                                                                  | Лёгкая  | Цикл + аккумулятор                           |
| 40 | **Длина вектора (норма L2)**                    | `||v|| = √(Σ v[i]²)`. Вернуть `float64`.                                                | Лёгкая  | Квадратный корень из суммы квадратов         |
| 41 | **Норма L1 (манхэттенская)**                    | `||v||₁ = Σ |v[i]|`.                                                                    | Лёгкая  | Сумма модулей                                |
| 42 | **Норма L∞ (чебышёвская)**                      | `||v||∞ = max(|v[i]|)`.                                                                 | Лёгкая  | Поиск максимума по модулю                    |
| 43 | **Нормализация вектора**                        | Вернуть единичный вектор: `v / ||v||`.                                                  | Средняя | Деление на L2-норму                          |
| 44 | **Проверка ортогональности**                    | Два вектора ортогональны, если `a · b == 0`.                                            | Лёгкая  | Скалярное произведение                       |
| 45 | **Угол между векторами (в радианах)**           | `cosθ = (a·b) / (||a|| * ||b||)`. Вернуть `θ`.                                          | Средняя | `math.Acos` + скалярное произведение         |

|*46 | Простая нейросеть (XOR на матрицах)              | Реализовать и обучить с нуля нейросеть (2→4→1), решающую задачу XOR, используя только матричные операции и градиентный спуск.| Прямой/обратный проход, ReLU + Sigmoid, backpropagation |

Скользящее окно (Sliding Window):

| №  | Название задачи                                        | Описание                                                                                           | Сложность  | Тип / Подход                        |
| -- | ------------------------------------------------------ | -------------------------------------------------------------------------------------------------- | ---------- | ------------------------------------|
| 1  | **Длиннейшая подстрока без повторяющихся символов**    | Найти длину самой длинной части строки, где все символы уникальны.                                 | Средняя | Скользящее окно, Хеш-таблица           |
| 2  | **Минимальное окно-подстрока (Поиск тегов)**           | Найти кратчайшую подстроку, которая содержит все ключевые слова из списка.                         | Сложная | Скользящее окно, Частотный анализ      |
| 3  | **Подмассив с заданной суммой (Целевой бюджет)**       | Найти непрерывный подмассив, сумма которого равна заданному значению.                              | Средняя | Скользящее окно, Префиксные суммы      |
| 4  | **Начало анаграмм (Анализ текстов)**                   | Найти все индексы, где начинается анаграмма заданного слова.                                       | Средняя | Скользящее окно, Частотный анализ      |
| 5  | **Максимальный средний балл (Прогноз)**                | Найти окно длиной K с максимальным средним значением.                                              | Лёгкая  | Скользящее окно, Суммы                 |
| 6  | **Максимум в скользящем окне**                         | Для каждого окна K найти максимальное значение.                                                    | Сложная | Дек, Скользящее окно                   |
| 7  | **Максимальное число последовательных периодов**       | В бинарном массиве найти длину самого длинного участка из 1, если можно изменить не более K нулей. | Средняя | Скользящее окно, Два указателя         |
| 8  | **Самая короткая подстрока с K уникальными символами** | Найти длину минимальной подстроки, содержащей ровно K уникальных символов.                         | Сложная | Скользящее окно, Хеш-таблица           |
| 9  | **Подмассив с произведением меньше K**                 | Подсчитать количество подмассивов, произведение элементов которых < K.                             | Средняя | Скользящее окно, Два указателя         |
| 10 | **Минимальная длина подмассива (сумма ≥ S)**           | Найти минимальную длину окна, сумма элементов которого ≥ S.                                        | Средняя | Скользящее окно, Два указателя         |
| 11 | **Средняя температура за K дней**                      | Рассчитать массив средних значений для каждого окна длиной K.                                      | Лёгкая  | Скользящее окно, Префиксные суммы      |
| 12 | **Максимальное число клиентов в смене**                | Найти момент, когда одновременно находилось максимум клиентов.                                     | Средняя | Временные интервалы, Скользящее окно   |
| 13 | **Максимальная прибыль с двумя транзакциями**          | Найти максимальную прибыль, совершив две сделки без пересечения.                                   | Сложная | Динамическое программирование, Массивы |
| 14 | **Минимальное количество товаров для набора**          | Найти минимальное окно, содержащее хотя бы один экземпляр каждого из K ингредиентов.               | Сложная | Скользящее окно, Частотный анализ      |
| 15 | **Длиннейшая последовательность покупок**              | Найти самую длинную последовательность, где каждый товар встречается не более K раз.               | Средняя | Скользящее окно, Хеш-таблица           |

# Интервалы (Intervals)

|  № | Название задачи                               | Описание                                                                              |  Сложность | Тип / Подход                                                    |
| -: | --------------------------------------------- | ------------------------------------------------------------------------------------- | :--------: | ----------------------------------------------------------------|
|  1 | **Слияние интервалов (Объединение встреч)**   | Объединить пересекающиеся интервалы, получить сводное расписание.                     | Лёгкая  | Сортировка по началу + объединение (O(n log n))                    |
|  2 | **Вставка интервала (Новая задача)**          | Вставить новый интервал в отсортированный список и при необходимости объединить.      | Средняя | Поиск позиции + объединение соседей                                |
|  3 | **Непересекающиеся интервалы (Оптимизация)**  | Минимальное число удалений, чтобы не было перекрытий.                                 | Средняя | Сортировка по окончанию + жадный выбор (аналог activity selection) |
|  4 | **Пересечение интервалов (Общее время)**      | Найти пересечение двух списков интервалов (время, когда оба доступны).                | Лёгкая  | Два указателя по двум спискам                                      |
|  5 | **Интервалы планировщика (Ресурсы)**          | Найти минимальное количество комнат, необходимых для всех встреч.                     | Средняя | События (start +1, end −1) или heap (min-heap по окончанию)        |
|  6 | **Проверка на пересечение**                   | Проверить, пересекаются ли два заданных интервала.                                    | Лёгкая  | Простая арифметическая проверка (start1 ≤ end2 && start2 ≤ end1)   |
|  7 | **Пересечение двух списков интервалов**       | Найти все интервалы, когда оба ресурса были активны.                                  | Средняя | Два указателя, пересечения пар интервалов                          |
|  8 | **Минимальное количество стрел (Кампании)**   | Минимальное число точек (стрел), чтобы перекрыть все интервалы.                       | Сложная | Сортировка по окончанию + жадный выбор (interval scheduling)       |
|  9 | **Добавление интервалов (Начисление)**        | Применить "добавки" (напр., бонусы) к соответствующим временным интервалам.           | Средняя | Дифф-массив / sweep line (накопление значений по интервалам)       |
| 10 | **Перезагрузка интервалов (Свободное время)** | Вернуть интервалы свободного времени (когда человек не занят).                        | Средняя | Инверсия интервалов относительно рабочего диапазона + объединение  |
| 11 | **Конфликты в расписании**                    | Вернуть все интервалы, когда оба человека свободны для встречи.                       | Средняя | Интерсекция расписаний (два указателя)                             |
| 12 | **Планирование встреч**                       | Можно ли запланировать новую встречу длительности D в доступном времени?              | Средняя | Поиск пробелов между занятиями (после слияния)                     |
| 13 | **Загруженность сервера**                     | Найти максимум одновременно подключённых пользователей.                               | Средняя | Sweep line (события) или сортировка всех start/end                 |
| 14 | **Календарь занятости (Summary)**             | Вернуть минимальный набор непересекающихся интервалов, покрывающих всё занятое время. | Лёгкая  | Сортировка + merge (аналог слияния интервалов)                     |
| 15 | **Конфликты в бронировании**                  | Проверить, есть ли пересечение в бронированиях для одной переговорной.                | Лёгкая  | Сортировка по началу + проверка соседей                            |

---

Matrics + Backtracking Search

| #  | Категория                  | Название Задачи                         | Описание Матрицы / Цель                                                                                     | Принцип Backtracking                                                                                                                               |
|----|----------------------------|---------------------------------------- |-------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | Размещение                 | Проблема N-Ферзей (N-Queens)            | Матрица N×N. Найти все способы размещения N ферзей без конфликтов.                                          | Проверять безопасность хода в каждой строке. При неудаче возврат к предыдущему столбцу.                                                            |
| 2  | Распределение              | Решение Судоку (Sudoku Solver)          | Матрица 9×9. Заполнить пустые ячейки цифрами, соблюдая правила.                                             | Находить пустую ячейку. Пробовать цифры 1..9. Если ограничение нарушено, возврат и проба следующей цифры.                                          |
| 3  | Поиск Пути                 | Крепость в Лабиринте (Rat in a Maze)    | Бинарная матрица M×N (проходы/стены). Найти все пути от старта до финиша.                                   | Рекурсивно исследовать доступные направления. При тупике или стене возврат к предыдущей клетке.                                                    |
| 4  | Обход                      | Рыцарский Обход (Knight's Tour)         | Матрица N×N (шахматная доска). Посетить каждую клетку ровно один раз ходом рыцаря.                          | Пробовать 8 ходов рыцаря. Если ход ведет на посещённую клетку, возврат и проба другого хода.                                                       |
| 5  | Поиск Комбинаций           | Поиск Слова в Сетке (Word Search)       | Матрица M×N с буквами. Найти все слова, соединяя соседние клетки.                                           | Рекурсивно исследовать 8 соседних клеток. Если последовательность не формирует слово, возврат и проба другого направления.                         |
| 6  | Генерация Путей            | Все Простые Пути в Матрице              | Матрица M×N. Найти все пути от (0,0) до (M-1,N-1), двигаясь только вправо/вниз.                             | Рекурсивно пробовать два хода: вправо и вниз. Если ход за границу, возврат.                                                                        |
| 7  | Минимальный Путь           | Сбор Золота в Шахте (Max Weighted Path) | Взвешенная матрица M×N. Найти путь с максимальной суммой, двигаясь вправо, вправо-вверх или вправо-вниз.    | Рекурсивно перебирать 3 возможных хода. Использовать отсечение (прунинг), если текущая сумма становится слишком мала.                              |
| 8  | Сложный Путь               | Лабиринт с Ключами и Дверями            | Матрица M×N с объектами (ключи, двери). Найти путь, собирая нужные ключи для дверей.                        | Рекурсивно исследовать путь, отслеживая состояние инвентаря. При запертой двери без ключа возврат.                                                 |
| 9  | Генерация Форм             | Разбиение Полимино (Polyomino Tiling)   | Матрица M×N. Покрыть матрицу заданным набором полимино без наложений.                                       | Пробовать разместить следующую фигуру в первой свободной клетке. Если фигура не помещается, возврат и проба другой ориентации/фигуры.              |
| 10 | Раскраска                  | Раскраска Графа (по матрице смежности)  | Матрица N×N (соседство областей). Назначить цвета областям карты, чтобы соседи имели разные цвета.          | Рекурсивно назначать цвет следующей области. Если цвет конфликтует с соседом, возврат и проба следующего цвета.                                    |
| 11 | Поиск Элементов            | Расстановка Мин (Minesweeper Solver)    | Матрица N×N. Определить все возможные безопасные положения мин, исходя из числовых подсказок.               | Рекурсивно предполагать, является ли клетка миной или нет. Если предположение нарушает подсказки соседей, возврат.                                 |
| 12 | Генерация                  | Генерация Кроссворда (Simplified)       | Матрица M×N. Разместить слова из списка в сетке так, чтобы они пересекались и не нарушали правила.          | Пробовать разместить следующее слово в доступном месте. Если размещение блокирует другие слова, возврат.                                           |
| 13 | Бинарное Покрытие          | Проблема Домино (Domino Tiling)         | Матрица M×N. Покрыть всю матрицу плитками домино (1×2) без наложений.                                       | Найти первую свободную клетку. Пробовать разместить домино вертикально или горизонтально. Если размещение невозможно, возврат.                     |
| 14 | Перестановки               | Размещение Объектов с Ограничениями     | Матрица M×N. Разместить K объектов так, чтобы они не находились на одной линии.                             | Рекурсивно перебирать ячейки для размещения объекта. Если новое размещение нарушает ограничение, возврат.                                          |
| 15 | Разделение                 | Разбиение на Квадраты (Matrix Partition)| Матрица N×N. Найти все способы разрезать матрицу на заданное количество меньших непересекающихся квадратов. | Рекурсивно выбирать линию разреза (горизонтальную или вертикальную). Если разрезание не приводит к нужным квадратам, возврат и выбор другой линии. |
| 16 | Поиск Островов             | Подсчёт островов                        | Матрица M×N (0/1). Посчитать количество «островов» (соединённых единиц).                                    | Рекурсивно (DFS) отмечать и считать соединённые компоненты. При обнаружении острова возврат после полного обхода.                                  |
| 17 | Заливка                    | Заливка области (Flood Fill)            | Матрица M×N с цветами. Изменить цвет области, соединённой одинаковыми цветами, начиная с заданной клетки.   | Рекурсивно исследовать 4/8 соседей. Если цвет совпадает, изменить и продолжить; иначе возврат.                                                     |
| 18 | Проверка                   | Проверка симметрии                      | Квадратная матрица N×N. Проверить симметрию относительно главной диагонали.                                 | Рекурсивно сравнивать элементы симметрично. При несоответствии возврат false.                                                                      |
| 19 | Сумма Элементов            | Сумма всех элементов                    | Матрица M×N с числами. Найти сумму всех элементов рекурсивно.                                               | Рекурсивно суммировать по строкам/столбцам. Базовый случай: пустая матрица или конец строки.                                                       |
| 20 | Переворот                  | Переворот матрицы                       | Квадратная матрица N×N. Повернуть на 90° по часовой стрелке рекурсивно.                                     | Рекурсивно менять элементы в циклах (4 угла). Разделять на подматрицы.                                                                             |
| 21 | Поиск Максимума            | Поиск максимального элемента            | Матрица M×N с числами. Найти максимальное число рекурсивно.                                                 | Рекурсивно сравнивать элементы по строкам/столбцам. Базовый случай: один элемент.                                                                  |
| 22 | Генерация Комбинаций       | Генерация всех комбинаций клеток        | Матрица M×N. Сгенерировать все возможные последовательности клеток длины k.                                 | Рекурсивно выбирать/пропускать клетки. При достижении длины k добавлять в результат; иначе возврат.                                                |
| 23 | Минимальный Путь           | Путь с минимальной стоимостью           | Взвешенная матрица M×N. Найти путь с минимальной суммой весов от старта до финиша.                          | Рекурсивно перебирать возможные ходы с мемоизацией. При превышении минимума прунинг и возврат.                                                     |
| 24 | Обход Змейкой              | Змейка (Snake pattern)                  | Матрица M×N. Обойти матрицу «змейкой» (по спирали) и собрать элементы в список рекурсивно.                  | Рекурсивно удалять границы матрицы (верх, право, низ, лево). Базовый случай: пустая матрица.                                                       |
| 25 | Подсчёт Квадратов          | Подсчёт квадратов единиц                | Бинарная матрица M×N. Посчитать все квадраты размера k x k, заполненные единицами.                          | Рекурсивно проверять подматрицы на заполненность. При несоответствии возврат.                                                                      |
| 26 | Поиск Фигур                | Подсчёт всех L-образных фигур           | Матрица M×N (0/1). Найти все L-образные фигуры (3 клетки).                                                  | Рекурсивно перебирать позиции и ориентации. Если фигура не подходит, возврат.                                                                      |
| 27 | Конвертация                | Рекурсивная конвертация матрицы в список| Матрица M×N. Преобразовать в одномерный список рекурсивно.                                                  | Рекурсивно добавлять элементы по строкам/столбцам. Базовый случай: конец строки/матрицы.                                                           |
| 28 | Подсчёт Периметра          | Подсчёт периметра островов              | Матрица M×N (0/1). Для каждой группы единиц (острова) посчитать периметр рекурсивно.                        | Рекурсивно (DFS) считать границы острова (смежные с 0 или краем). При посещении клетки возврат после подсчёта соседей.                             |



