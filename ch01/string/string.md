# 1. Разворот слов в адресе

**Идея:** сохранить слова в исходном виде, но поменять их порядок на обратный. Мы работаем по словам (разделитель — пробелы или другие разделители адреса).

**Шаги решения (пошагово):**

1. Разбить строку на список слов по разделителям (обычно пробелы; можно учитывать табы/множественные пробелы).
2. Игнорировать пустые «слова», которые возникли из-за нескольких пробелов (или сохранять, если нужно сохранить формат).
3. Перевернуть порядок элементов списка (последнее становится первым и т. п.).
4. Объединить слова обратно в строку, вставив разделитель (обычно один пробел) между ними.
5. (Опция) Если нужно сохранить изначальные ведущие/замыкающие пробелы или пунктуацию, учесть это отдельно — хранить префиксы/суффиксы и восстанавливать.

**Граничные случаи:**

* Пустая строка → вернуть пустую строку.
* Строка из одного слова → вернуть то же слово.
* Множество пробелов между словами → решить, нужно ли их сжимать до одного.
* Адрес с запятыми/точками (например: `ул. Ленина, д. 5`) — пунктуация остаётся частью слова, если не обработать отдельно.

**Пример:**
Вход: `"ул. Ленина 10 кв. 5"`
Разбив: `["ул.", "Ленина", "10", "кв.", "5"]`
Переворот: `["5", "кв.", "10", "Ленина", "ул."]`
Выход: `"5 кв. 10 Ленина ул."`

**Сложность:** O(n) по времени (n — длина строки), O(n) по памяти для списка слов.

---

# 2. Проверка анаграмм (Кодовые слова)

**Идея:** две строки являются анаграммами, если у них одинаковый набор символов с одинаковыми частотами (игнорируя, возможно, пробелы и регистр — в зависимости от постановки задачи).

**Шаги решения:**

1. (Опция) Нормализовать строки: привести к одному регистру (например, нижнему), удалить пробелы и, возможно, пунктуацию, если нельзя учитывать их.
2. Посчитать, сколько раз встречается каждый символ в первой строке и во второй (используется словарь/массив счётчиков).
3. Сравнить таблицы частот: если совпадают для всех символов, строки — анаграммы; иначе — нет.

Альтернативный подход: отсортировать символы в каждой строке и сравнить отсортированные строки — если одинаковы, то анаграммы. Сортировка обычно проще концептуально, но чуть дороже по времени.

**Граничные случаи:**

* Пустые строки: обычно считаются анаграммами друг друга.
* Строки разной длины после нормализации → не анаграммы.
* Учитывать ли пробелы, регистр, диакритические символы — уточнить требования.

**Пример:**
Вход: `"listen"`, `"silent"` → после подсчёта частот: совпадают → анаграммы.
Вход: `"Astronomer"`, `"Moon starer"` → после нормализации (удалить пробелы и нижний регистр) → `"astronomer"` vs `"moonstarer"` → анаграммы.

**Сложность:**

* Подсчёт частот — O(n) время, O(k) память (k — число уникальных символов).
* Сортировка — O(n log n) время, O(n) память.

---

# 3. Самый длинный общий префикс (Файлы)

**Идея:** найти максимальную начальную часть (последовательность символов от начала) общей для всех строк в массиве.

**Шаги решения (пошагово):**

1. Если массив пуст — общий префикс пустой.
2. Можно взять одну эталонную строку (обычно первую) и по символам её проверять: для каждого индекса i проверить, что все строки имеют тот же символ на позиции i.
3. Остановиться на первом несовпадении — префикс это всё до i (не включая i).
4. Возвратить найденную подстроку из эталонной строки.

Альтернативы:

* Отсортировать массив строк лексикографически: общий префикс всех строк равен общему префиксу между первой и последней строкой после сортировки — это полезно, когда строк много, но сортировка добавляет логарифмическую сложность.
* Параллельное деление и завоевание (divide & conquer) или три-пары (Trie) для более продвинутых сценариев.

**Граничные случаи:**

* Массив из одной строки → сама строка.
* Есть пустая строка → общий префикс пуст.
* Списки URL — учитывать, что префикс может обрезаться в середине компонента (например `https://` одинаково).

**Пример:**
Вход: `["/home/user/docs/report.doc", "/home/user/docs/notes.txt", "/home/user/docs/"]`
Общий префикс: `"/home/user/docs/"`.

**Сложность:** O(m * n) в худшем случае, где m — длина эталонной строки, n — количество строк (проверка каждого символа эталонной строки по всем строкам). Сортировка-альтернатива: O(n log n * L) где L — средняя длина строки для сравнения при сортировке.

---

# 4. Проверка скобок (Код/Конфиг)

**Идея:** проверить, что скобки открываются и закрываются в правильном порядке и соответствуют типу — классическая задача для стека.

**Шаги решения:**

1. Пройти по символам строки слева направо.
2. Когда встретили открывающую скобку `(`, `[`, `{` — поместить её в стек (запоминать тип).
3. Когда встретили закрывающую скобку `)`, `]`, `}` — проверить стек:

    * Если стек пуст → ошибка (закрывающая без соответствующей открывающей).
    * Иначе взять верхний элемент стека и убедиться, что он соответствует типу закрывающей (например, `(` соответствует `)`).
    * Если соответствует — извлечь верх (pop) и продолжать, иначе → ошибка (несовпадающий тип).
4. По окончании прохода: если стек пуст — скобки корректны; если в стеке остались элементы — есть незакрытые скобки → некорректно.

**Граничные случаи и расширения:**

* Игнорировать не-скобочные символы (обычно).
* Вложенные скобки разного типа — правильно обрабатываются стеком (`[{()}]` корректно).
* Пропуск строковых литералов/комментариев в коде (если анализируете код): скобки внутри строк/комментариев не должны влиять — это усложняет задачу (нужен парсер лексики).
* Поддержка других пар символов — просто расширить правила соответствия.

**Пример:**

* `"({[]})"` → корректно (стек проходит, пуст в конце).
* `"(]"` → некорректно (встретили `]`, а верх стека — `(`).
* `"(()"` → некорректно (в конце стек не пуст).

**Сложность:** O(n) по времени и O(n) по памяти (стек в худшем случае хранит все открытые скобки).

---

# 5. Преобразование в целое число (Парсинг)

**Идея:** реализовать парсер, который читает строку слева направо, учитывает знак, цифры и обрабатывает переполнение (если результат выходит за допустимый диапазон).

**Шаги решения (пошагово):**

1. Пропустить ведущие пробелы (если по спецификации они допускаются).
2. Проверить первый значимый символ: `+` или `-` для знака; сохранить знак (+1 или −1). Если нет знака — считать положительным.
3. Идти по символам дальше, пока идут цифры (`0`–`9`):

    * На каждом шаге обновлять текущий накопленный результат: `result = result * 10 + digit`.
    * Перед обновлением проверять переполнение: если `result` уже больше `(MAX - digit) / 10`, то при конечном знаке произойдёт выход за границу → вернуть ограничение (например, `INT_MAX` или `INT_MIN`) либо сигнал ошибки, в зависимости от требований.
4. При первом нецифровом символе — остановиться и вернуть накопленное число с учётом знака (часть строки после числа игнорируется).
5. Если не встретилось ни одной цифры → вернуть ошибку или 0 (зависит от спецификации задачи).

**Граничные случаи:**

* Пустая строка или строка без цифр → нужно определить поведение (возврат 0 или ошибка).
* Очень большие числа → правильная обработка переполнения.
* Знаки больше одного (например `"--1"` или `"+-2"`) — обычно первый знак учитывается, дальше — стоп.
* Ведущие нули (`"000123"`) — нормальная ситуация.
* Символы после числа (`"42abc"`) — обычно парсер останавливается на `a` и возвращает 42.

**Пример (32-битный диапазон):**

* Вход: `"   -42"` → после пропуска пробелов и знака результат `-42`.
* Вход: `"4193 with words"` → `4193`.
* Вход: `"9223372036854775808"` (слишком большое) → вернуть `INT_MAX` (или другой оговоренный предел).
* Вход: `"words and 987"` → вернуть 0 или ошибку (в зависимости от спецификации, т.к. цифры не начинаются в начале).

**Сложность:** O(n) по времени (n — длина строки), O(1) по памяти (вместо арифметических переменных и счётчиков).

# 6. Проверка изоморфных SKU

**Идея:** Две строки изоморфны, если существует взаимнооднозначное сопоставление символов одной строки в символы другой, сохраняющее порядок. То есть каждый символ первой строки всегда отображается в один и тот же символ второй, и никаких двух разных символов первой строки не отображается в один и тот же символ второй (и наоборот).

**Шаги решения:**

1. Проверить равную длину строк — если не равны, то не изоморфны.
2. Создать две хеш-таблицы (или одно отображение и обратное): `map1` для сопоставления символов из A→B и `map2` для B→A.
3. Пройти по позициям i от 0 до n−1:

   * Если `a = A[i]`, `b = B[i]`.
   * Если `map1` содержит `a` и `map1[a] != b` — противоречие → не изоморфны.
   * Если `map2` содержит `b` и `map2[b] != a` — противоречие → не изоморфны.
   * Иначе установить `map1[a]=b` и `map2[b]=a`.
4. Если цикл завершился без противоречий — изоморфны.

**Граничные случаи:**

* Пустые строки — считаются изоморфными.
* Строки разной длины — не изоморфны.
* Повторяющиеся символы — должны соответствовать одному и тому же отображению.
* Если нужно игнорировать регистр/специальные символы — нормализовать заранее.

**Пример:**

* `"foo"` и `"app"` → изоморфны (`f→a`, `o→p`).
* `"bar"` и `"foo"` → не изоморфны (`b→f`, `a→o`, `r→o` — конфликт, два символа в A отображаются в один символ в B).

**Сложность:** O(n) по времени, O(k) по памяти (k — размер алфавита/уникальных символов).

---

# 7. Шифр Цезаря (Rot13)

**Идея:** Сдвинуть каждую букву алфавита на фиксированное количество позиций по кругу. Rot13 — частный случай: сдвиг на 13 для латинского алфавита; при применении дважды восстанавливается оригинал.

**Шаги решения (обобщённо):**

1. Для каждого символа строки:

   * Если это буква (латинская), определить её порядковый номер в алфавите (учесть регистр).
   * Добавить смещение (например, 13), затем взять остаток по длине алфавита (26) — тем самым «оборачивая» при выходе за `z`.
   * Заменить символ на получившийся.
   * Нелитеральные символы (пробелы, цифры, пунктуация) обычно оставлять без изменений.
2. Собрать результатную строку.

**Граничные случаи / вариации:**

* Поддержка только латиницы или других алфавитов (кириллица требует другой логики).
* Сохранение регистра: `A`→`N`, `a`→`n`.
* Смещение может быть любым (необязательно 13) — общий Caesar cipher.

**Пример (Rot13):**

* `"Hello, World!"` → `"Uryyb, Jbeyq!"`
* Применив Rot13 ещё раз, вернём исходную строку.

**Сложность:** O(n) по времени, O(1) дополнительной памяти (кроме результата).

---

# 8. Самый часто повторяющийся символ (Статистика)

**Идея:** Посчитать частоту каждого символа и выбрать символ(ы) с максимальной частотой.

**Шаги решения:**

1. Создать хеш-таблицу частот.
2. Пройти по всем символам строки и для каждого увеличить счётчик.
3. Пройти по таблице частот и найти символ с максимальным значением (если нужно — несколько символов при равенстве).
4. (Опция) Резолв при равенстве: вернуть любой, первый по порядку появления или отсортировать по коду символа.

**Граничные случаи:**

* Пустая строка → вернуть «нет символа» или нулевой результат.
* Учитывать пробелы/переносы/регистр — нужно заранее уточнить (нормализовать или нет).
* Unicode: может быть много символов; учитывать сложные символы и комбинирующие знаки — в простом подходе считается по кодовым точкам.

**Пример:**

* Вход: `"abbccc"` → ответ: `'c'` (3 раза).
* Вход: `"a a b"` → если считать пробелы, то `' '` может быть самым частым.

**Сложность:** O(n) по времени и O(k) по памяти (k — число уникальных символов).

---

# 9. Проверка на палиндром-перестановку

**Идея:** Можно ли переставить символы строки так, чтобы получился палиндром? Условие: для палиндрома все символы должны иметь чётные частоты, за исключением максимум одного символа (в центре) — если длина результирующего палиндрома нечётна.

**Шаги решения:**

1. Посчитать частоты всех символов (обычно игнорируют пробелы и регистр — зависит от требований).
2. Посчитать количество символов с нечётной частотой (`oddCount`).
3. Если `oddCount <= 1` → перестановка в палиндром возможна; иначе — нет.

**Граничные случаи:**

* Пустая строка — считается палиндромом (возвращает true).
* Строка с одним символом — true.
* Если пробелы/пунктуация не должны учитываться — удалить их перед подсчётом.

**Пример:**

* `"carrace"` → частоты: c:2, a:2, r:2, e:1 → `oddCount = 1` → можно (например `"racecar"`).
* `"daily"` → несколько символов с нечётными частотами → нельзя.

**Сложность:** O(n) по времени, O(k) памяти.

---

# 10. Сокращение пути (Unix-стиль)

**Идея:** Упростить путь, удалив `.` (текущая директория), корректно обработав `..` (подняться на уровень) и лишние слэши.

**Шаги решения:**

1. Разбить путь по разделителю `/` на части (компоненты).
2. Использовать стек для компонентов:

   * Игнорировать пустые компоненты и `"."`.
   * Если встречается `".."` — если стек не пуст, выполнить pop (подняться на уровень); если пуст и путь абсолютный — оставаться в корне (не добавлять `..`), если относительный — возможно сохранять `..` (в зависимости от требований).
   * Иначе добавить компонент в стек.
3. После обработки собрать путь:

   * Для абсолютного пути (`/` в начале) — результат `"/" + join(stack, "/")` (если стек пуст — просто `"/"`).
   * Для относительного — просто `join(stack, "/")` (если пустая — `"."` или пусто по требованию).

**Граничные случаи:**

* Абсолютный vs относительный путь — разная семантика `..` в начале.
* Много подряд `////` — считаем как одиночный разделитель.
* Конец пути со слэшем — обычно нормализуется (убирается), но можно сохранить по требованию.
* Компоненты с `..` превышающими верхнюю точку для относительного пути — можно сохранить ведущие `..`.

**Пример:**

* `"/a/./b/../c/"` → разобьём: `["", "a", ".", "b", "..", "c", ""]` → стек → `["a","c"]` → `"/a/c"`.
* `"a/b/../../c"` (относительный) → стек попеременно → результат `"../c"` или `"c"` в зависимости от начального состояния — обычно `"../c"`.

**Сложность:** O(n) времени и O(n) памяти (стек).

---

# 11. Преобразование Excel столбца

**Идея:** Буквенное обозначение столбца Excel — это представление числа в системе с основанием 26, но без нуля (A=1, B=2, ..., Z=26, AA=27 и т.д.). Нужно преобразовать буквы в число.

**Шаги решения:**

1. Инициализировать результат `result = 0`.
2. Пройти по буквам слева направо:

   * Для каждой буквы `ch` получить её позицию `val = (код буквы — код('A')) + 1`.
   * Обновить `result = result * 26 + val`.
3. В конце `result` — числовой индекс столбца (1-based).

**Граничные случаи:**

* Ввод в нижнем регистре — привести к верхнему.
* Пустая строка — невалидно.
* Ограничения по длине — Excel имеет предел (например, Excel раньше имел до XFD — 16384 столбца), но алгоритм работает для любой длины, возвращая большие числа.

**Пример:**

* `"A"` → `1`.
* `"Z"` → `26`.
* `"AA"` → `26*1 + 1 = 27`.
* `"ZZ"` → `26*26 + 26 = 702`.
* `"AAA"` → `26*702 + 1 = 18279`.

**Сложность:** O(n) по времени, O(1) по памяти.

---

# 12. Валидация IP-адреса (IPv4)

**Идея:** IPv4 — четыре десятичных числа от 0 до 255, разделённые точками, без ведущих нулей (в большинстве норм) или с ними — зависит от требований.

**Шаги решения:**

1. Разбить строку по `.` на четыре части; если не ровно 4 — невалидно.
2. Для каждой части:

   * Проверить, что она не пустая.
   * Проверить, что все символы — цифры (0–9).
   * (Опция) Проверить отсутствие ведущих нулей, если длина > 1 и первый символ `'0'` — невалидно (если требование).
   * Преобразовать в число и проверить диапазон `0 ≤ x ≤ 255`.
3. Если все четыре части корректны — адрес валиден.

**Граничные случаи:**

* `"0.0.0.0"` — валиден.
* `"255.255.255.255"` — валиден.
* `"01.2.3.4"` — часто считается невалидным из-за ведущего нуля (зависит от правила).
* Неправильные символы, пустые части, больше/меньше 4 частей — невалидно.

**Пример:**

* `"192.168.1.1"` → валиден.
* `"256.100.0.1"` → невалиден (256 > 255).
* `"192.168.1"` → невалиден (меньше 4 частей).

**Сложность:** O(n) времени, O(1) памяти (количество частей фиксировано).

---

# 13. Парсинг CSV

**Идея:** CSV может содержать поля, разделённые запятыми, где поле может быть заключено в кавычки; внутри кавычек запятая считается частью поля, а двойная кавычка `""` обозначает литеральную `"` внутри поля. Это требует автомата состояний/лексера.

**Шаги решения (высокоуровнево):**

1. Использовать автомат с двумя основными состояниями: внутри кавычек и вне кавычек.
2. Инициализировать пустое текущее поле, список полей.
3. Пройти по каждому символу:

   * Если в состоянии *не в кавычках*:

      * Если символ — запятая → завершить поле, добавить в список и начать новое.
      * Если символ — кавычка `"` → перейти в состояние *в кавычках*.
      * Иначе — добавить символ в текущее поле.
   * Если в состоянии *в кавычках*:

      * Если символ — кавычка `"` → проверить следующий символ (если есть):

         * Если следующий тоже кавычка → это экранированная кавычка «двойная двойная»; добавить одну `"` в поле и пропустить следующий.
         * Иначе → конец кавычечного поля — перейти в состояние *не в кавычках*.
      * Иначе — добавить символ в текущее поле.
4. По окончании строки — добавить последнее поле.
5. Обработать ошибки: незакрытые кавычки — синтаксическая ошибка.

**Граничные случаи:**

* Пустые поля: `",,"` → три пустых поля.
* Поля в кавычках с запятыми: `"a, b",c` → `["a, b","c"]`.
* Поля, содержащие кавычки: `"He said ""Hi"""` → поле `He said "Hi"`.
* Разные стандарты: CRLF, строки с пробелами вокруг запятых — часто пробелы вне кавычек должны сохраняться или быть подрезаны по правилам.

**Сложность:** O(n) по времени, O(k) памяти (временная строка и список полей). Реализация требует аккуратного управления состоянием и ошибок.

---

# 14. Форматирование валюты

**Идея:** Преобразовать число в строку с разделителями тысяч, фиксированным количеством знаков после запятой и включением символа валюты (например, `€`, `$`), возможно с учётом локали (разделитель дробной части `.` или `,`).

**Шаги решения (высокоуровнево):**

1. Определить формат: символ валюты (перед/после), количество знаков после запятой, разделитель тысяч (пробел, запятая) и дробный разделитель.
2. Отделить знак (минус/плюс).
3. Округлить/отрезать число до нужного количества знаков после запятой.
4. Разделить на целую и дробную части.
5. Для целой части: идти с конца и вставлять разделитель тысяч каждые 3 цифры.
6. Собрать обратно: знак + (символ валюты + пробел?) + целая + дробная часть (через дробный разделитель).
7. (Опция) Поддержка отрицательных значений в скобках `(€1,234.56)` — в зависимости от стандарта.

**Граничные случаи:**

* Очень большие числа — корректно форматировать.
* Нулевые/отрицательные значения.
* Локализованные форматы (в Финляндии/Европе часто дробный разделитель — запятая, разделитель тысяч — пробел).
* Валюта с плавающим символом (например, `USD 1,234.56` vs `1 234,56 €`).

**Пример:**

* Вход: `1234567.891`, формат: `symbol=$` перед числом, 2 знака → `"$1,234,567.89"`.
* Вход: `-1234.5`, формат EU → `"-1 234,50 €"`.

**Сложность:** O(n) по числу цифр, O(1) дополнительной памяти.

---

# 15. Кодирование URL (замена пробелов на `%20`)

**Идея:** В URL пробелы недопустимы — их заменяют на `%20`. Для общего URL-энкодинга есть набор символов, которые нужно кодировать; но если требуется только замена пробелов — задача проще.

**Шаги решения (простая версия — только пробелы):**

1. Пройти по строке и заменить каждый пробел (или последовательность пробелов, в зависимости от требований) на `%20`.
2. Если нужно учитывать другие символы (например, `?`, `#`, `/` и т.д.) — применять полный URL-encoding (процентное кодирование UTF-8 байтов).

**Граничные случаи:**

* Несколько подряд пробелов — заменить каждый на `%20` или заменить группу на один? (обычно каждый пробел кодируется отдельно → `%20%20`).
* Не латинские символы — для полного кодирования необходимо сначала получить байтовое представление (UTF-8), затем каждую байтовую единицу вне допустимого набора кодировать как `%HH`.
* Если URL уже содержит `%20` — не декодировать обратно; при повторном кодировании `%` также будет закодирован (→ `%25`), поэтому может потребоваться проверка/предварительная обработка.

**Пример:**

* `"Hello World"` → `"Hello%20World"`.
* `"a b  c"` → `"a%20b%20%20c"` (если кодировать каждый пробел).

**Сложность:** O(n) по времени, O(n) по памяти (новая строка).

---

### **16. Сжатие строки (RLE-компрессия)**

**Описание:**
Дана строка вроде `"aaabbcddd"`, нужно получить `"a3b2c1d3"`.
(И наоборот — можно восстановить исходную строку.)

**Идея:**
Это классическая задача на **итерацию и подсчёт одинаковых символов подряд**.

1. Берём первый символ и начинаем считать, сколько раз он подряд повторяется.
2. Когда встречается другой символ — записываем результат (например, `"a3"`) и продолжаем с новым.
3. В конце объединяем всё в строку.

**Обратная операция:**
Чтобы “разжать” строку — читаем символ и следующее число, и повторяем символ указанное количество раз.

**Пример:**

* `"aaabbcddd"` → `"a3b2c1d3"`
* `"a3b2c1d3"` → `"aaabbcddd"`

**Применение:**
Используется в простых алгоритмах сжатия данных (например, в изображениях RLE или текстовых форматах).

---

### **17. Удаление дубликатов символов**

**Описание:**
Из строки `"banana"` получить `"ban"` — то есть оставить только **первое вхождение** каждого символа.

**Идея:**

1. Завести структуру, где мы храним уже встреченные символы (например, множество).
2. Проходим по строке слева направо.
3. Если символ ещё не встречался — добавляем его в результат.
4. Если уже был — пропускаем.

**Пример:**

* `"banana"` → `"ban"`
* `"abracadabra"` → `"abrcd"`

**Применение:**
Используется, например, при очистке данных, когда нужно убрать повторения символов или кодов.

---

### **18. Самое длинное слово в предложении**

**Описание:**
Найти слово с наибольшей длиной в строке, игнорируя пунктуацию.

**Идея:**

1. Удалить из строки все знаки препинания (`. , ! ? ; :`).
2. Разбить строку по пробелам.
3. Для каждого слова посчитать длину и найти максимальную.
4. Можно вернуть и само слово, и его длину.

**Пример:**

* `"Сегодня прекрасный солнечный день!"` → `"прекрасный"` (10 букв)
* `"Fly high, dream big!"` → `"dream"` (5 букв)

**Применение:**
Полезно при анализе текстов, обработке вводов пользователя или поиске ключевых слов.

---

### **19. Проверка корректности e-mail адреса**

**Описание:**
Проверить, соответствует ли строка базовому формату `user@domain.com`.

**Идея:**

1. Проверяем, что в строке есть **ровно один символ `@`**.
2. Перед `@` и после него должны быть непустые части.
3. После `@` должен быть хотя бы один `.` и что-то после него.
4. Не должно быть пробелов, спецсимволов в начале или конце.

**Пример:**
✅ `"user@example.com"`
❌ `"user@@example.com"`
❌ `"@example.com"`
❌ `"user@.com"`

**Применение:**
Используется валидация форм, проверка данных пользователей, API и т.д.

---

### **20. Подсветка ключевых слов в тексте**

**Описание:**
Например, у нас есть текст и список ключевых слов — нужно обернуть их в `<b>...</b>`.

**Пример:**
Текст: `"Моя кошка любит молоко"`
Ключевое слово: `"кошка"`
Результат: `"Моя <b>кошка</b> любит молоко"`

**Идея:**

1. Идём по каждому ключевому слову.
2. Находим все вхождения этого слова в тексте.
3. Вставляем перед ним `<b>` и после `</b>`.
4. Важно не “вложить” теги друг в друга, если слова пересекаются.
   Иногда используется регулярное выражение с заменой всех вхождений слова на тегированную версию.

**Применение:**
Используется в поисковых системах, системах комментариев, выделении совпадений при фильтрации текста и т.д.

---

### **21. Нормализация пробелов в тексте**

**Цель:** сделать строку аккуратной, убрав все лишние пробелы.
**Логика:**

1. Разбиваем строку по пробелам — получится список слов (в котором пустые строки будут означать лишние пробелы).
2. Удаляем пустые элементы.
3. Объединяем слова обратно через один пробел.
4. Это автоматически уберёт пробелы в начале, в конце и между словами.

**Пример:**
`"  Привет   мир   !" → "Привет мир !"`

---

### **22. Проверка сложности пароля**

**Цель:** убедиться, что пароль "надёжный".
**Логика:**

1. Нужно проверить 4 условия:

   * есть хотя бы одна **строчная** буква (a–z);
   * есть хотя бы одна **заглавная** буква (A–Z);
   * есть хотя бы одна **цифра** (0–9);
   * есть хотя бы один **спецсимвол** (`!@#$%^&*...`).
2. Каждое условие можно проверить перебором или через регулярные выражения.
3. Если все 4 выполняются — пароль считается сложным.

**Пример:**
✅ `Qwerty@123` — подходит
❌ `password123` — нет заглавных и спецсимволов

---

### **23. Извлечение домена из URL**

**Цель:** получить только домен, без протокола, пути и параметров.
**Логика:**

1. Убираем префикс `http://` или `https://`.
2. Удаляем `www.` — если есть.
3. Отрезаем всё, что идёт после первого `/`.
4. Остаток и есть домен.

**Пример:**
`https://www.google.com/maps?q=...` → `google.com`

---

### **24. Подсчёт слов в тексте**

**Цель:** посчитать количество реальных слов.
**Логика:**

1. Убираем все знаки препинания (`.,!?;:` и т.п.).
2. Разделяем строку по пробелам.
3. Убираем пустые элементы (если между словами несколько пробелов).
4. Считаем длину списка слов.

**Пример:**
`"Привет, мир! Это тест." → 4 слова`

---

### **25. Проверка шаблона имени файла**

**Цель:** убедиться, что строка подходит под заданный формат (например, `file_###.txt`).
**Логика:**

1. Понимаем, что `#` — это любое число.
2. Значит, нужно проверить, что:

   * строка начинается с `"file_"`;
   * после этого идёт **ровно 3 цифры**;
   * и заканчивается на `.txt`.
3. Можно проверить посимвольно или через регулярное выражение (`file_\d{3}\.txt`).

**Пример:**
✅ `file_123.txt`
❌ `file_12.txt` или `file_abc.txt`

---

