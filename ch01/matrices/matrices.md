# Матрицы (итерационные решения, без рекурсии) — подробные учебные объяснения

---


# 1. Спиральный обход склада

**Задача.** Обойти матрицу по спирали и вернуть все элементы в порядке обхода (внешний контур → внутрь), без рекурсии.

### Идея (концепция)

Поддерживаем четыре границы: `top` (верхняя строка, ещё не пройдена), `bottom` (нижняя), `left` (левая колонка), `right` (правая). На каждом шаге идём по одной стороне текущего прямоугольника и затем сдвигаем соответствующую границу внутрь. Повторяем, пока `top <= bottom` и `left <= right`.

### Инвариант

Перед каждой итерацией цикла все элементы вне текущего прямоугольника уже обработаны; внутри — ещё нет. После каждого прохода одна граница сдвигается, размер прямоугольника уменьшается.

### Алгоритм (итерации)

1. Инициализировать `top = 0`, `bottom = n-1`, `left = 0`, `right = m-1` (n — число строк, m — число столбцов).
2. Пока `top <= bottom` и `left <= right`:

    * Идём слева направо по строке `top` от `left` до `right`. Добавляем элементы. Увеличиваем `top`.
    * Идём сверху вниз по столбцу `right` от `top` до `bottom`. Добавляем элементы. Уменьшаем `right`.
    * Если `top <= bottom`: идём справа налево по строке `bottom` от `right` до `left`. Добавляем элементы. Уменьшаем `bottom`.
    * Если `left <= right`: идём снизу вверх по столбцу `left` от `bottom` до `top`. Добавляем элементы. Увеличиваем `left`.
3. Конец — все элементы в порядке спирали.

### Псевдокод

```
top = 0; bottom = n-1; left = 0; right = m-1
result = []
while top <= bottom and left <= right:
    for j in left..right:
        result.append(A[top][j])
    top += 1

    for i in top..bottom:
        result.append(A[i][right])
    right -= 1

    if top <= bottom:
        for j in right..left step -1:
            result.append(A[bottom][j])
        bottom -= 1

    if left <= right:
        for i in bottom..top step -1:
            result.append(A[i][left])
        left += 1
return result
```

### Временная и пространственная сложность

* Время: O(n·m) — каждый элемент посещается ровно один раз.
* Память: O(1) дополнительной (помимо выходного списка результата), либо O(n·m) если считать результат.

### Крайние случаи

* Пустая матрица (n=0 или m=0) → результат пуст.
* Одна строка или один столбец — алгоритм корректно обойдёт их.
* Нечётные размеры приводят к одиночной центральной ячейке — покрывается условиями `top <= bottom` и `left <= right`.

### Вариации

* Спираль в обратном направлении (по часовой/против часовой) — поменять порядок проходов и сдвиги границ.
* Начало с другого угла — скорректировать начальные границы/порядок проходов.

---

# 2. Поворот изображения (90° по часовой стрелке)

**Задача.** Повернуть квадратную матрицу `n×n` на 90° по часовой стрелке, делая операцию in-place (без выделения дополнительной `n×n` матрицы).

### Идея (концепция)

Два распространённых подхода:

**Вариант A — транспонирование + реверс строк**

1. Транспонировать матрицу (поменять `A[i][j]` и `A[j][i]` для всех `i<j`).
2. Для каждой строки выполнить реверс (переставить элементы в строке в обратном порядке).

**Вариант B — циклический обмен по «кольцам» (по слоям)**
Для каждого слоя (от внешнего к внутреннему) поэлементно вращать четыре соответствующих позиции (верх-лево → верх-право → низ-право → низ-лево → назад).

Оба варианта итерационные, без рекурсии.

### Почему транспонирование + реверс работает?

Транспонирование меняет строки и столбцы: `A'[i][j] = A[j][i]`. Затем реверс строки превращает `i`-ю строку транспонированной матрицы в итоговую повернутую на 90°.

### Псевдокод (Вариант A)

```
# 1. Транспонирование (in-place)
for i in 0..n-1:
    for j in i+1..n-1:
        swap(A[i][j], A[j][i])

# 2. Реверс каждой строки
for i in 0..n-1:
    reverse(A[i])  # меняем A[i][j] с A[i][n-1-j]
```

### Псевдокод (Вариант B — по слоям)

```
for layer in 0..(n/2 - 1):
    first = layer
    last = n - 1 - layer
    for i in first..last-1:
        offset = i - first
        top = A[first][i]                 # сохранить верх
        A[first][i] = A[last - offset][first]         # левый -> верх
        A[last - offset][first] = A[last][last - offset]  # низ -> левый
        A[last][last - offset] = A[i][last]           # правый -> низ
        A[i][last] = top                              # верх -> правый
```

### Сложность

* Время: O(n²) — каждый элемент меняет позицию константное число раз.
* Память: O(1) дополнительной.

### Крайние случаи

* `n = 0` или `n = 1` — ничего менять не надо.
* Матрица не квадратная — метод применим только к квадратным матрицам; для прямоугольных нужен другой подход с выделением новой матрицы `m×n`.

### Вариации

* Поворот на 90° против часовой стрелки: можно транспонировать и затем реверсить столбцы, либо применить три раза поворот по часовой.
* Поворот на 180°: транспонирование + реверс каждой строки и затем реверс порядка строк (или просто двойной цикл обмена).

---

# 3. Установка нулей (Распространение ошибки)

**Задача.** Если элемент матрицы равен 0, то обнулить всю строку и весь столбец (классическая задача). Требование — сделать итерационно, эффективно по памяти.

### Простая, но неэффективная идея

На первом проходе записать все координаты нулей, потом во втором проходе обнулить соответствующие строки и столбцы. Но хранение списка координат может стоить O(k) памяти (k — число нулей), что в худшем случае O(n·m).

### Умный способ (использовать первую строку и первый столбец как флаги)

1. Проход по матрице; используем `first_row_has_zero` и `first_col_has_zero` для флага, есть ли ноль в первой строке/первом столбце.
2. Для остальных элементов (i>0, j>0): если `A[i][j]==0`, пометить `A[i][0] = 0` и `A[0][j] = 0`.
3. Второй проход: для всех i>0 и j>0, если `A[i][0]==0` или `A[0][j]==0`, установить `A[i][j]=0`.
4. Наконец, обнулить первую строку/первый столбец при необходимости.

### Псевдокод

```
first_row_zero = any(A[0][j] == 0 for j in 0..m-1)
first_col_zero = any(A[i][0] == 0 for i in 0..n-1)

for i in 1..n-1:
    for j in 1..m-1:
        if A[i][j] == 0:
            A[i][0] = 0
            A[0][j] = 0

for i in 1..n-1:
    for j in 1..m-1:
        if A[i][0] == 0 or A[0][j] == 0:
            A[i][j] = 0

if first_row_zero:
    for j in 0..m-1: A[0][j] = 0

if first_col_zero:
    for i in 0..n-1: A[i][0] = 0
```

### Сложность

* Время: O(n·m) — два прохода по матрице.
* Память: O(1) дополнительной (пару булевых переменных).

### Крайние случаи

* Если матрица 1×1 — корректно обработается.
* Если первая строка/столбец содержат нули — именно для них используются отдельные флаги, чтобы не потерять информацию, помещая метки в `A[0][*]` и `A[*][0]`.

### Вариации

* Если допустима дополнительная память O(n + m), можно хранить два булевых массива `rows` и `cols`.
* Можно требовать минимальное число записей — оптимизация не нужна в учебном варианте.

---

# 4. Проход по диагоналям (Анализ данных)

**Задача.** Вывести элементы матрицы по диагоналям, причём диагонали группируются по сумме индексов `i + j` (сначала диагональ с суммой 0, затем 1 и т.д.). Итеративно.

### Идея

Все ячейки с одинаковой суммой индексов лежат на одной диагонали, и сумма индексов `s` принимает значения `0..(n-1 + m-1)`. Для каждой `s` пробегаем все возможные `i` такие, что `j = s - i` в пределах `0..m-1`.

Можно менять порядок внутри диагонали (например, вверх или вниз) по требованию.

### Псевдокод

```
for s in 0..(n-1 + m-1):
    for i in max(0, s - (m-1))..min(n-1, s):
        j = s - i
        output A[i][j]
```

(Пояснение предельных значений: `i` не меньше 0 и не больше `n-1`; `j = s - i` должен быть в `0..m-1`, поэтому `i >= s-(m-1)`.)

### Сложность

* Время: O(n·m) — каждый элемент выводится ровно один раз.
* Память: O(1) дополнительной (помимо вывода).

### Крайние случаи

* Нечёткая матрица (одна строка или один столбец) — диагонали будут содержать ровно по 1 элемент или более, корректно обрабатывается.

### Вариации

* Диагонали по разности индексов (`i - j`) — тогда ключом является `i - j` и диапазон будет другой (от `-(m-1)` до `n-1`).
* Поворот направления (сначала справа-налево внутри диагонали и т.д.).

---

# 5. Тепловая карта (усреднение по 3×3 окну)

**Задача.** Для каждой ячейки заменить значение средним (или целочисленным средним) значений в её соседстве 3×3 (центр + восемь соседей). Итерационно, без рекурсии. Обычно требуется не испортить исходные данные при вычислении — значит, результат записывать в новую матрицу или аккуратно хранить промежуточные значения.

### Идея

Проходим по всем ячейкам; для каждой берём сумму всех существующих соседних ячеек в окрестности `i-1..i+1`, `j-1..j+1`, учитывая границы, считаем количество реально существующих ячеек (особенно на краях и углах) и делим сумму на количество — получаем среднее. Записываем результат в новую матрицу `B` того же размера, чтобы исходная `A` оставалась неизменной при обработке соседей.

### Псевдокод

```
B = matrix n×m (инициализирована нулями)
for i in 0..n-1:
    for j in 0..m-1:
        sum = 0
        count = 0
        for di in -1..1:
            for dj in -1..1:
                ni = i + di
                nj = j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    sum += A[ni][nj]
                    count += 1
        B[i][j] = sum / count   # либо floor/round, если требуется целое
return B
```

### Сложность

* Время: O(n·m) * O(1) (поскольку 3×3 — константа) → O(n·m).
* Память: O(n·m) для новой матрицы-результата; можно уменьшить память при специальных требованиях (строчное буферизирование), но обычно используется отдельная матрица.

### Крайние случаи

* Пустая матрица — ничего не делать.
* Границы — считать только существующие соседи.

### Вариации и оптимизации

* Если нужно быстро пересчитывать среднее для многих окон (скользящее среднее), можно использовать префиксные суммы (integral image) для сумм областей произвольного размера за O(1), тогда общая сложность O(n·m) с меньшей константой.
* Использовать свёртку с ядром `1/9` (или с весами) — обычный подход в обработке изображений.

---

# Подробная пошаговая трассировка (побуквенно) — **Спиральный обход**

Возьмём конкретную матрицу 4×4, заполненную буквами для наглядности:

```
A = [
  [A, B, C, D],
  [E, F, G, H],
  [I, J, K, L],
  [M, N, O, P]
]
```

Мы хотим вывести элементы в порядке спирали (по часовой стрелке, начиная с верхнего левого угла). Ожидаемый результат: `A, B, C, D, H, L, P, O, N, M, I, E, F, G, K, J` — но мы пройдём пошагово и объясним каждое действие.

### Инициализация

* `top = 0`
* `bottom = 3` (n−1)
* `left = 0`
* `right = 3` (m−1)
* `result = []`

### Итерация 1

Условие: `top (0) <= bottom (3)` и `left (0) <= right (3)` → выполняем тело.

1. **Проход слева направо по строке `top = 0`**, `j` в `[left..right] = [0..3]`:

    * j=0 → взять `A[0][0] = A` → result = [A]
    * j=1 → `A[0][1] = B` → result = [A, B]
    * j=2 → `A[0][2] = C` → result = [A, B, C]
    * j=3 → `A[0][3] = D` → result = [A, B, C, D]
      После этого `top += 1` → `top = 1`.

2. **Проход сверху вниз по столбцу `right = 3`**, `i` в `[top..bottom] = [1..3]`:

    * i=1 → `A[1][3] = H` → result = [A, B, C, D, H]
    * i=2 → `A[2][3] = L` → result = [A, B, C, D, H, L]
    * i=3 → `A[3][3] = P` → result = [A, B, C, D, H, L, P]
      После этого `right -= 1` → `right = 2`.

3. Проверка `top <= bottom`? `1 <= 3` → да. **Проход справа налево по строке `bottom = 3`**, `j` в `[right..left]` = `[2..0]` (включительно, в обратном порядке):

    * j=2 → `A[3][2] = O` → result = [A, B, C, D, H, L, P, O]
    * j=1 → `A[3][1] = N` → result = [A, B, C, D, H, L, P, O, N]
    * j=0 → `A[3][0] = M` → result = [A, B, C, D, H, L, P, O, N, M]
      После этого `bottom -= 1` → `bottom = 2`.

4. Проверка `left <= right`? `0 <= 2` → да. **Проход снизу вверх по столбцу `left = 0`**, `i` в `[bottom..top]` = `[2..1]` (в обратном порядке):

    * i=2 → `A[2][0] = I` → result = [A, B, C, D, H, L, P, O, N, M, I]
    * i=1 → `A[1][0] = E` → result = [A, B, C, D, H, L, P, O, N, M, I, E]
      После этого `left += 1` → `left = 1`.

**Итог после итерации 1:**
`top = 1, bottom = 2, left = 1, right = 2`
result = `[A, B, C, D, H, L, P, O, N, M, I, E]`
Осталась центральная 2×2 область:

```
[ F, G ]
[ J, K ]  (индексы: строки 1..2, столбцы 1..2)
```

---

### Итерация 2

Условие: `top (1) <= bottom (2)` и `left (1) <= right (2)` → выполняем.

1. **Слева направо по строке `top = 1`**, `j` в `[1..2]`:

    * j=1 → `A[1][1] = F` → result = [..., F]
      result становится `[A, B, C, D, H, L, P, O, N, M, I, E, F]`
    * j=2 → `A[1][2] = G` → добавляем → result = `[..., F, G]`

   `top += 1` → `top = 2`.

2. **Сверху вниз по столбцу `right = 2`**, `i` в `[2..2]`:

    * i=2 → `A[2][2] = K` → result = `[A, B, C, D, H, L, P, O, N, M, I, E, F, G, K]`

   `right -= 1` → `right = 1`.

3. Проверка `top <= bottom`? `2 <= 2` → да. **Справа налево по `bottom = 2`**, `j` в `[1..1]` (обратный шаг, но здесь только одно значение):

    * j=1 → `A[2][1] = J` → добавляем → result = `[... , K, J]`
      `bottom -= 1` → `bottom = 1`.

4. Проверка `left <= right`? `1 <= 1` → да. **Снизу вверх по `left = 1`**, `i` в `[bottom..top] = [1..2]` но сейчас `bottom=1`, `top=2` → при использовании обратного порядка `[bottom..top step -1]` фактически цикл пуст, так как `bottom < top` — в алгоритме мы обычно проверяем `if left <= right` и then `for i in bottom..top step -1` — но после уменьшения `bottom` и увеличения `top` уже может ничего не пройти. В нашем проходе ничего не добавится.

Однако после шагов у нас `top = 2`, `bottom = 1`, `left = 2`, `right = 1` — цикл завершится.

**Итог после итерации 2:**
result = `[A, B, C, D, H, L, P, O, N, M, I, E, F, G, K, J]`

Это окончательный порядок — все 16 букв обработаны.

---

### Результат (последовательность)

`A, B, C, D, H, L, P, O, N, M, I, E, F, G, K, J`

Каждый шаг — явное прохождение стороны прямоугольника и сдвиг границы; на каждом шаге граница гарантированно сужает область, и процесс завершится после посещения всех элементов.

---

# 6 — Проверка судоку (9×9)

**Задача.** Проверить, что в 9×9 сетке нет повторов чисел 1..9 в каждой строке, в каждом столбце и в каждом 3×3 блоке.

### Идея

Итерировать по строкам, столбцам и 3×3 блокам и проверять отсутствие дубликатов. Для проверки удобно использовать множества (`set`) или булевы массивы длины 9. Если встречаем пустые ячейки (например `.`), их игнорируем — зависит от постановки задачи (полное/частичное судоку).

### Инвариант

При проверке каждой строки/столбца/блока множество содержит только уникальные числа, встреченные до текущей позиции; повторение — ошибка.

### Алгоритм (итерационно)

1. Для каждой строки `i`:

    * Завести пустое множество `seen`.
    * Пройти по всем `j` от 0 до 8: если `cell = A[i][j]` — не пустая — проверить, есть ли `cell` в `seen`; если есть — неверно; иначе добавить.
2. Для каждого столбца `j` — аналогично.
3. Для каждого 3×3 блока (их 9): индекс блока по `(block_row, block_col)` в `0..2`. Внутри пройти 3×3 и проверять дубликаты.

Можно объединить все три проверки в один проход по всем клеткам, используя три структуры: массив множеств для строк (`rows[9]`), для столбцов (`cols[9]`) и для блоков (`blocks[9]`), где `block_index = (i/3)*3 + (j/3)`.

### Псевдокод (объединённый вариант)

```
rows = array[9] of empty sets
cols = array[9] of empty sets
blocks = array[9] of empty sets

for i in 0..8:
  for j in 0..8:
    val = A[i][j]
    if val is empty: continue
    if val in rows[i]: return false
    add val to rows[i]
    if val in cols[j]: return false
    add val to cols[j]
    block = (i / 3) * 3 + (j / 3)
    if val in blocks[block]: return false
    add val to blocks[block]

return true
```

### Сложность

* Время: O(9·9) = O(1) по сути (константа), но формально O(n²) если обобщать (n = 9).
* Память: O(9+9+9) = O(1) (константная).

### Крайние случаи / комментарии

* Если строки/столбцы могут содержать числа вне диапазона 1..9 — предварительно валидировать.
* Если пустые ячейки допустимы — игнорировать их.
* Вариант: проверка только завершённого судоку (без пустых) — тогда ещё проверять, что каждое множество имеет размер 9.

---

# 7 — Самая большая область 1 (через гистограмму)

**Задача.** В бинарной матрице (0/1) найти максимальную площадь прямоугольника, полностью заполненного `1`. Подход: преобразование каждой строки в гистограмму высот и решение задачи «наибольший прямоугольник в гистограмме» с помощью стека.

### Идея

Рассматриваем каждую строку как «основание» прямоугольника. Для каждой колонки поддерживаем `height[j]` — количество подряд идущих единиц, заканчивающихся в текущей строке (если `A[i][j]==1`, то `height[j] += 1`, иначе `height[j] = 0`). Тогда задача для строки превращается в классическую «максимальная площадь прямоугольника в гистограмме» для массива `height[]`. Проходим по всем строкам и берём максимум.

### Инвариант

Перед обработкой строки `i` массив `height` корректно отражает высоты столбиков единиц, включая строку `i`. Алгоритм для одной гистограммы возвращает правильную максимальную прямоугольную площадь, ограниченную базой в этой строке.

### Алгоритм (внешний цикл + стек для гистограммы)

1. Инициализировать `height[j] = 0` для всех `j`.
2. Для каждой строки `i`:

    * Для каждого столбца `j`: если `A[i][j] == 1` → `height[j] += 1` иначе `height[j] = 0`.
    * Рассчитать `maxAreaInHistogram(height)` — классический алгоритм со стеком (O(m)).
    * Обновить глобальный максимум площади.

### Псевдокод — максимальная площадь в гистограмме (stack)

```
function maxAreaInHistogram(H[0..m-1]):
    stack = empty stack (будет хранить индексы)
    maxArea = 0
    for j in 0..m:   # заметка: идём до m включительно, представляем H[m] = 0 sentinel
        currentHeight = (j == m) ? 0 : H[j]
        while stack not empty and currentHeight < H[stack.top]:
            height = H[stack.pop()]
            width = if stack empty then j else j - stack.top - 1
            maxArea = max(maxArea, height * width)
        push j onto stack
    return maxArea
```

### Сложность

* Для каждой строки: обновление `height` — O(m), вычисление площади гистограммы — O(m). Всего O(n·m).
* Память: O(m) для `height` и стека.

### Крайние случаи / оптимизации

* Если матрица большая, это оптимально — O(n·m).
* Альтернативный подход: динамическое программирование комбинируя левые/правые границы (сложнее в реализации).
* Нужно аккуратно использовать sentinel ноль в конце для «очистки» стека.

---

# 8 — Зеркальное отражение по вертикали (по оси Y)

**Задача.** Отразить матрицу по вертикальной оси: для каждой строки поменять порядок колонок (реверс строк).

### Идея

Для каждой строки выполнить обмен `A[i][j] <-> A[i][m-1-j]` для `j` от `0` до `m/2-1`. Это in-place, итерационно.

### Псевдокод

```
for i in 0..n-1:
    for j in 0..(m/2 - 1):
        swap(A[i][j], A[i][m-1-j])
```

### Сложность

* Время: О(n·m) (каждый элемент может быть обменян один раз).
* Память: O(1) дополнительной.

### Крайние случаи / варианты

* Не квадратная матрица — всё равно работает (операции например для 3×4 корректны).
* Вертикальное отражение ≠ транспонирование.

---

# 9 — Транспонирование не квадратной матрицы (m×n → n×m)

**Задача.** Поменять местами строки и столбцы: получить новую матрицу `B` размера `m'×n'` где `B[j][i] = A[i][j]`. Для прямой in-place операции матрица должна быть квадратной; для прямоугольной — выделяем новую матрицу.

### Идея

Простой двойной цикл: для каждого `i` и `j` записать `B[j][i] = A[i][j]`.

### Псевдокод

```
B = matrix of size m×n swapped => size m' = m? careful: если A is n×m then B is m×n
for i in 0..n-1:
    for j in 0..m-1:
        B[j][i] = A[i][j]
return B
```

(Дословно: если A размер n×m, то B будет m×n, B[j][i] = A[i][j].)

### Сложность

* Время: O(n·m).
* Память: O(n·m) для новой матрицы; in-place возможно только если n==m.

### Крайние случаи / замечания

* Если нужно in-place для прямоугольной — требуется сложная перестановка элементов в одном массиве (cycle decomposition) — редко нужно.
* Для языков/структур с гибкими размерами (например вектор вектор) проще создать новую матрицу.

---

# 10 — Сумма подматрицы (Финансовый отчёт) — 2D префиксные суммы

**Задача.** Для заданной матрицы `A` и запроса `[r1,c1,r2,c2]` вернуть сумму элементов подматрицы, где `r1<=r2`, `c1<=c2`. Требуется отвечать на запросы быстро (много запросов) — используем 2D префиксные суммы (integral image).

### Идея

Построить матрицу префиксов `P` того же размера, где `P[i][j]` — сумма всех элементов `A[0..i][0..j]` (включительно). Тогда сумма любой прямоугольной области вычисляется за константу по формуле включений-исключений:

```
sum(r1,c1,r2,c2) = P[r2][c2]
                    - (r1>0 ? P[r1-1][c2] : 0)
                    - (c1>0 ? P[r2][c1-1] : 0)
                    + (r1>0 and c1>0 ? P[r1-1][c1-1] : 0)
```

### Построение `P`

Можно построить в одном проходе:

```
for i in 0..n-1:
  for j in 0..m-1:
    above = (i>0) ? P[i-1][j] : 0
    left  = (j>0) ? P[i][j-1] : 0
    diag  = (i>0 and j>0) ? P[i-1][j-1] : 0
    P[i][j] = A[i][j] + above + left - diag
```

### Псевдокод (полный)

```
# Построение P
P = zero matrix n×m
for i in 0..n-1:
  for j in 0..m-1:
    P[i][j] = A[i][j]
    if i > 0: P[i][j] += P[i-1][j]
    if j > 0: P[i][j] += P[i][j-1]
    if i > 0 and j > 0: P[i][j] -= P[i-1][j-1]

# Запрос суммы
function query(r1,c1,r2,c2):
  res = P[r2][c2]
  if r1 > 0: res -= P[r1-1][c2]
  if c1 > 0: res -= P[r2][c1-1]
  if r1 > 0 and c1 > 0: res += P[r1-1][c1-1]
  return res
```

### Сложность

* Построение: O(n·m).
* Один запрос: O(1).
* Память: O(n·m) для `P` (можно оптимизировать, если требуется потоковая обработка запросов в особых условиях).

### Крайние случаи / замечания

* Индексация: внимательно с нулевой индексацией; при использовании 1-based индексов формулы немного проще (нет проверок на `>0`).
* Для частных задач можно использовать Fenwick Tree 2D (BIT) для обновлений и запросов в O(log n · log m), если нужны динамические обновления.

---
Отлично — продолжаем (без пошаговой трассировки). Ниже — подробные учебные описания для задач **№11–20** в том же формате: идея, инвариант / замысел, пошаговый итеративный алгоритм, псевдокод, сложность, крайние случаи и возможные вариации / оптимизации.

---

# 11 — Поворот на 180° и 270° (обобщённый поворот)

**Задача.** Реализовать поворот матрицы на 90°, 180°, 270° (по часовой). Подход — комбинация транспонирования и реверса / повторное применение 90°.

### Идея

* 90° по часовой: транспонировать + реверс каждой строки (или циклический обмен по слоям).
* 180°: можно выполнить как два поворота по 90°, либо симметрично: для каждой ячейки `A[i][j]` поменять с `A[n-1-i][m-1-j]` (для прямоугольной матрицы).
* 270° (или 90° против часовой): транспонировать + реверс столбцов, либо выполнить три раза поворот на 90°.

### Инвариант

После каждого шага (транспонирование или реверс) структура матрицы корректно движется к требуемому повороту; при in-place операциях мы не теряем данные, потому что обмены выполняются попарно.

### Алгоритм (варианты)

1. **90° (квадратная):**

    * Транспонировать (меняем `A[i][j]` ⇄ `A[j][i]` для `i<j`).
    * Для каждой строки выполнить реверс (или swap `A[i][j]` ⇄ `A[i][n-1-j]`).

2. **180° (любая размерность n×m):**

    * Для всех `i` в `0..n-1` и `j` в `0..m-1` (или лишь половины): swap `A[i][j]` ⇄ `A[n-1-i][m-1-j]`. Выполнять только для позиций, которые “лежат до своей пары” (например, при линейной индексации `idx < total/2`), чтобы не поменять обратно.

3. **270°:**

    * Транспонировать и затем реверсить **столбцы** (или выполнить 90° три раза).

### Псевдокод (180° — общий; 90° для квадратной)

```
# 180°, in-place (общий n×m)
total = n * m
for idx in 0..(total/2 - 1):
    i1 = idx / m; j1 = idx % m
    idx2 = total - 1 - idx
    i2 = idx2 / m; j2 = idx2 % m
    swap(A[i1][j1], A[i2][j2])
```

```
# 90° (квадратная n×n)
# 1) transpose
for i in 0..n-1:
  for j in i+1..n-1:
    swap(A[i][j], A[j][i])
# 2) reverse rows
for i in 0..n-1:
  reverse(A[i])
```

### Сложность

* 90° (квадратная): O(n²) время, O(1) доп. память (in-place).
* 180°: O(n·m) время, O(1) память.
* 270°: эквивалент 90°.

### Крайние случаи / замечания

* Для прямоугольной матрицы 90° in-place невозможен без переразмеривания — требуется выделение новой матрицы размера `m×n`.
* При 180° обязательно корректно обрабатывать центральный элемент (когда `total` нечётно) — он остаётся на месте.

---

# 12 — Ротация колец (Циклический сдвиг слоёв)

**Задача.** Сдвинуть элементы матрицы по кольцам (слоям) на заданное количество позиций `k` (можно влево/вправо или по часовой/против часовой).

### Идея

Матрица имеет `layers = ceil(min(n,m)/2)` слоёв (кольца). Для каждого слоя:

1. Превратить элементы кольца в один линейный массив (в порядке обхода кольца).
2. Выполнить циклический сдвиг этого массива на `k mod L`, где `L` — длина кольца.
3. Записать сдвинутые значения обратно в кольцо.

Такой подход прост, универсален и легко интуитивен.

### Инвариант

До обработки слоя `t` кольца `0..t-1` уже сдвинуты; при извлечении линейного массива порядок обхода должен быть одинаков при вытаскивании и записи обратно.

### Алгоритм (детали извлечения и записи)

Для слоя с индексом `layer`:

* `top = layer`, `left = layer`, `bottom = n-1-layer`, `right = m-1-layer`.
* Собрать элементы:

    * Слева→справа по `top` (j = left..right).
    * Сверху→вниз по `right` (i = top+1..bottom).
    * Справа→влево по `bottom` (j = right-1..left), если `bottom > top`.
    * Снизу→вверх по `left` (i = bottom-1..top+1), если `left < right`.
* Получается массив `vals` длины `L`.
* Вычислить `k = k mod L`. Для сдвига вправо: new_index = (old_index + k) mod L; для сдвига влево — (old_index - k + L) mod L.
* Записать `vals_rotated` обратно в том же порядке обхода кольца.

### Псевдокод

```
layers = min(n,m) / 2 (целая часть)
for layer in 0..layers-1:
    top = layer; left = layer; bottom = n-1-layer; right = m-1-layer
    vals = []
    # collect
    for j in left..right: vals.append(A[top][j])
    for i in top+1..bottom: vals.append(A[i][right])
    if bottom > top:
        for j in right-1..left step -1: vals.append(A[bottom][j])
    if left < right:
        for i in bottom-1..top+1 step -1: vals.append(A[i][left])

    L = len(vals)
    if L == 0: continue
    k = k mod L   # направление по условию
    rotated = rotate_array(vals, k)  # реализовать через три реверса или временный массив

    # write back in same order
    idx = 0
    for j in left..right: A[top][j] = rotated[idx++]
    for i in top+1..bottom: A[i][right] = rotated[idx++]
    if bottom > top:
        for j in right-1..left step -1: A[bottom][j] = rotated[idx++]
    if left < right:
        for i in bottom-1..top+1 step -1: A[i][left] = rotated[idx++]
```

### Сложность

* Для каждого слоя длина кольца `L = O(perimeter) ~ O(2*(bottom-top+right-left))`. Общее время суммируется до O(n·m) — каждый элемент попадает в ровно один слой и обрабатывается константно.
* Память: O(L) дополнительной для временного массива текущего слоя; максимум — O(n+m).

### Крайние случаи / замечания

* Однострочные или одностолбцовые слои (когда `top==bottom` или `left==right`) — обход и запись должны корректно учитывать, чтобы не дублировать элементы.
* Направление сдвига: чётко указать (по часовой/против часовой или вправо/влево по линейному представлению кольца).
* Оптимизация: при очень большом `k` использовать `k mod L`.

### Вариации

* Можно сдвигать каждый слой на своё `k_layer`.
* Для in-place (без дополнительного массива) возможны циклические перестановки по индексам кольца, но реализация сложнее и менее прозрачна.

---

# 13 — Проверка симметрии матрицы

**Задача.** Проверить, что `matrix[i][j] == matrix[j][i]` для всех `i,j` (то есть матрица симметрична относительно главной диагонали).

### Идея

Проверять только половину матрицы (например, элементы над главной диагональю `i<j`) и сравнивать с соответствующими элементами под диагональю.

### Инвариант

Если для всех пар `i<j` верно равенство, матрица симметрична. Не нужно проверять диагональ (`i==j`).

### Псевдокод

```
if n != m: return false   # симметрия имеет смысл только для квадратной матрицы
for i in 0..n-1:
  for j in i+1..n-1:
    if A[i][j] != A[j][i]: return false
return true
```

### Сложность

* Время: O(n²/2) = O(n²).
* Память: O(1).

### Крайние случаи

* Несколько типов данных: сравнение должно учитывать тип (числа/символы/составные объекты) и возможно eps для float.
* Нечёткая матрица (не квадрат) → не симметрична.

---

# 14 — Сжатие данных (RLE 2D)

**Задача.** Сжать матрицу, записав повторяющиеся элементы вместе с количеством (run-length encoding). Требуется итеративный подход.

### Идея

Есть несколько вариантов, зависящих от требований к декодированию и структуре:

1. **По строкам (строковая RLE):** сжимать каждую строку отдельно — удобно и локально.
2. **Линейная RLE (сериализация 2D→1D):** пройти матрицу построчно (row-major) как единый поток и выполнять RLE по всему потоку (тогда последовательные одинаковые элементы на границе строки корректно объединяются).
3. **Блочная RLE (по прямоугольным областям):** более сложный — искать прямоугольники одинаковых значений (похож на 2D run-length, но сложнее).

Обычно используют вариант (1) или (2) в зависимости от необходимости сохранения границ строк.

### Инвариант

RLE хранит пары `(value, count)` последовательно для последовательных одинаковых значений в порядке обхода.

### Алгоритм (вариант row-major — поток по строкам, объединяет рядом стоящие через границу строки)

```
result = []
if n==0 or m==0: return result
current_val = A[0][0]
count = 1
for i in 0..n-1:
  for j in (i==0 ? 1 : 0)..m-1:   # первый элемент уже взят
    if A[i][j] == current_val:
      count += 1
    else:
      result.append((current_val, count))
      current_val = A[i][j]
      count = 1
# append final
result.append((current_val, count))
return result
```

---

# 15 — Замена диагоналей (главная ↔ побочная)

**Задача.** Поменять местами главную диагональ `A[i][i]` и побочную диагональ `A[i][n-1-i]` в квадратной матрице.

### Идея

Для каждой строки `i` выполнить swap между `A[i][i]` и `A[i][n-1-i]`. Если `i` указывает на центральную ячейку при `n` нечётном, то элемент меняется сам с собой — это безопасно.

### Инвариант

После выполнения для всех `i` диагонали полностью поменяны, остальные элементы не затрагиваются.

### Псевдокод

```
if n != m: error (нужна квадратная матрица)
for i in 0..n-1:
  j = n-1-i
  swap(A[i][i], A[i][j])
```

### Сложность

* Время: O(n).
* Память: O(1).

### Крайние случаи

* `n` нечётно: центральный элемент `i = n//2` остаётся на месте; swap безопасен.
* Если нужно одновременно поменять и другие диагонали (например, вторичная ↔ главная в нечётной матрице) — то всё аналогично.

---

# 16 — Сумма строк и столбцов

**Задача.** Посчитать сумму каждой строки и каждого столбца матрицы.

### Идея

Один проход по матрице, поддерживать массивы `rowSum[n]` и `colSum[m]`, пополняя их при обходе.

### Инвариант

После обработки `A[i][j]`, `rowSum[i]` содержит сумму элементов строки `i` до текущего столбца, `colSum[j]` — сумму столбца `j` до текущей строки.

### Псевдокод

```
rowSum = array[n] initialized to 0
colSum = array[m] initialized to 0

for i in 0..n-1:
  for j in 0..m-1:
    rowSum[i] += A[i][j]
    colSum[j] += A[i][j]

return (rowSum, colSum)
```

### Сложность

* Время: O(n·m).
* Память: O(n + m).

### Крайние случаи

* Пустые матрицы — массивы сумм пустые.
* Для больших чисел учитывать переполнение (использовать 64-bit или BigInt при необходимости).

---

# 17 — Транспонирование без доп. памяти (in-place)

**Задача.** Транспонировать **квадратную** матрицу in-place: `A[i][j]` ⇄ `A[j][i]`.

### Идея

Меняем местами элементы только для `i<j`, чтобы не менять их дважды и не трогать диагональ.

### Инвариант

После обработки всех пар `i<j` матрица транспонирована, диагональные элементы остаются на месте.

### Псевдокод

```
if n != m: error (in-place требует квадратную матрицу)
for i in 0..n-1:
  for j in i+1..n-1:
    swap(A[i][j], A[j][i])
```

### Сложность

* Время: O(n²).
* Память: O(1).

### Крайние случаи

* `n=0` или `n=1` — ничего не делать.

---

# 18 — Поиск максимального элемента

**Задача.** Найти максимальный элемент и его координаты `(i,j)`.

### Идея

Один проход по матрице, храним текущий максимум и его координаты, обновляем при встрече большего значения.

### Инвариант

После обработки элементов до текущей позиции, переменная `maxVal` — наибольшая из уже просмотренных элементов.

### Псевдокод

```
if n==0 or m==0: return None
maxVal = A[0][0]; maxPos = (0,0)
for i in 0..n-1:
  for j in 0..m-1:
    if A[i][j] > maxVal:
      maxVal = A[i][j]; maxPos = (i,j)
return (maxVal, maxPos)
```

### Сложность

* Время: O(n·m).
* Память: O(1).

### Вариации

* Найти несколько максимумов (все координаты значений, равных максимуму).
* Поддерживать топ-k максимумов — требуется структура (heap).

---

# 19 — Подсчёт чётных и нечётных

**Задача.** Посчитать количество чётных и нечётных чисел в матрице.

### Идея

Простой проход и классификация по `x % 2 == 0` (или битовой проверке).

### Псевдокод

```
even = 0; odd = 0
for i in 0..n-1:
  for j in 0..m-1:
    if A[i][j] % 2 == 0: even += 1
    else: odd += 1
return (even, odd)
```

### Сложность

* Время: O(n·m).
* Память: O(1).

### Крайние случаи

* Негативные числа — правило чётности сохраняется (в большинстве языков `%` требует аккуратности).

---

# 20 — Сдвиг строк вправо на k позиций (циклически)

**Задача.** Для каждой строки сдвинуть элементы на `k` позиций вправо циклически (элементы “выходят” справа и появляются слева).

### Идея

Для каждой строки делаем циклический сдвиг. Варианты реализации:

* Использовать временный массив `B[j] = A[i][(j - k_mod + m) % m]`.
* Использовать трёхкратный реверс (reverse whole, reverse first k, reverse rest) — in-place, O(1) доп. памяти.
* Использовать буфер длиной `k` и циклические перестановки.

### Инвариант

После обработки строки `i`, элементы в ней сдвинуты и не влияют на другие строки.

### Псевдокод (вариант с срезами / временной строкой)

```
k = k mod m
for i in 0..n-1:
  if k == 0: continue
  temp = array[m]
  for j in 0..m-1:
    temp[(j + k) % m] = A[i][j]
  A[i] = temp
```

### Псевдокод (in-place через реверс)

```
# shift right by k
k = k mod m
for each row:
  reverse(row, 0, m-1)
  reverse(row, 0, k-1)
  reverse(row, k, m-1)
```

(где `reverse` меняет порядок элементов на указанном отрезке)

### Сложность

* Время: O(n·m).
* Память: O(m) если временный массив, либо O(1) с методом трёх реверсов.

### Крайние случаи

* `k % m == 0` — строка не меняется.
* `m == 0` — ничего не делать.
* Для очень больших `k` обязательно использовать `k mod m`.

---

# 21 — Сдвиг столбцов вниз (циклически на k)

**Задача.** Для каждой колонки сдвинуть элементы на `k` позиций вниз циклически (элементы «выходят» вниз и появляются сверху).

### Идея

Обрабатывать каждую колонку отдельно: либо формировать временный массив размера `n` и записывать туда с индексной арифметикой `(i + k) % n`, либо выполнить in-place через метод срезов / реверсов (аналог трёх реверсов для строк).

### Инвариант

После обработки колонки `j` все её элементы сдвинуты на `k` позиций вниз и не влияют на другие колонки.

### Алгоритм (вариант с временным массивом — простой и безопасный)

1. Вычислить `k = k mod n` (где `n` — число строк). Если `k == 0` — ничего не делать.
2. Для каждой колонки `j`:

    * Создать `temp[0..n-1]`.
    * Для каждой строки `i` присвоить `temp[(i + k) % n] = A[i][j]`.
    * Записать `temp` обратно в колонку `j`: для `i` от 0 до `n-1` — `A[i][j] = temp[i]`.

### Псевдокод

```
k = k mod n
if k == 0: return
for j in 0..m-1:
  temp = array[n]
  for i in 0..n-1:
    dest = (i + k) % n
    temp[dest] = A[i][j]
  for i in 0..n-1:
    A[i][j] = temp[i]
```

### Сложность

* Время: O(n·m).
* Память: O(n) дополнительной на одну колонку; можно переиспользовать один `temp` для всех колонок.

### Крайние случаи / варианты

* `n == 0` или `m == 0` — ничего не делать.
* Можно реализовать in-place через реверсы по колонке: reverse whole column, reverse первые k, reverse остаток (аналогично строковому трёхреверсу), тогда доп. память O(1).
* Для очень больших `k` обязательно предварительно делать `k %= n`.

---

# 22 — Замена отрицательных на 0

**Задача.** Заменить в матрице все отрицательные числа на `0`.

### Идея

Прямой проход по всем элементам; если `A[i][j] < 0` — присвоить `0`. Итеративно, in-place.

### Инвариант

После обработки каждой ячейки значение в ней уже корректно (отрицательное → 0, иначе — без изменений).

### Псевдокод

```
for i in 0..n-1:
  for j in 0..m-1:
    if A[i][j] < 0:
      A[i][j] = 0
```

### Сложность

* Время: O(n·m).
* Память: O(1) дополнительной.

### Крайние случаи / замечания

* Для типов с плавающей точкой учитывать `-0.0` и погрешности сравнения.
* Если нужно считать статистику (сколько заменили), просто держать счётчик.
* Если матрица очень большая и хранится во внешнем хранилище, можно делать построчную обработку (стриминг).

---

# 23 — Умножение матрицы на число

**Задача.** Умножить все элементы матрицы на заданную константу `c`.

### Идея

Один проход: `A[i][j] *= c` для каждой ячейки. Поддерживается как in-place, так и запись в новую матрицу, если требуется неизменность исходной.

### Инвариант

После обработки `A[i][j]` содержит исходное значение, умноженное на `c`.

### Псевдокод (in-place)

```
for i in 0..n-1:
  for j in 0..m-1:
    A[i][j] = A[i][j] * c
```

### Сложность

* Время: O(n·m).
* Память: O(1) дополнительной (если in-place).

### Крайние случаи / замечания

* Если `c == 0` — матрица станет нулевой.
* Для целых типов следить за возможным переполнением; для чисел с плавающей точкой — за точностью.
* Можно вернуть новую матрицу `B` при необходимости сохранить `A`.

---

# 24 — Сумма диагоналей

**Задача.** Найти сумму главной диагонали (элементы `A[i][i]`) и побочной диагонали (элементы `A[i][n-1-i]`) для квадратной матрицы.

### Идея

Один проход по индексам `i = 0..n-1`. Добавлять `A[i][i]` к `sumMain` и `A[i][n-1-i]` к `sumAnti`. Если `n` нечётно, центральный элемент принадлежит обеим диагоналям — обычно считается дважды или один раз в зависимости от требования; обычно возвращают обе суммы отдельно, и пользователь сам решает, считать ли центр дважды при сумме обеих диагоналей.

### Псевдокод

```
if n != m: error (нужна квадратная матрица)
sumMain = 0
sumAnti = 0
for i in 0..n-1:
  sumMain += A[i][i]
  sumAnti += A[i][n-1-i]
return (sumMain, sumAnti)
```

### Сложность

* Время: O(n).
* Память: O(1).

### Крайние случаи / замечания

* Для `n` нечётного центральный элемент `i = n//2` входит в обе суммы; если нужно сумму обеих диагоналей без двойного учёта центрального элемента, вычесть `A[mid][mid]` один раз: `total = sumMain + sumAnti - (n%2==1 ? A[mid][mid] : 0)`.

---

# 25 — Обратный обход матрицы

**Задача.** Пройти матрицу в обратном порядке: снизу вверх и справа налево — т.е. последний элемент → первый (row-major в обратном порядке).

### Идея

Использовать обратные индексы в двух вложенных циклах: внешний цикл для строк от `n-1` до `0`, внутренний — для столбцов от `m-1` до `0`. Проход итеративный, простой.

### Псевдокод

```
for i in (n-1) downto 0:
  for j in (m-1) downto 0:
    process A[i][j]  # например, вывести или собрать в список
```

### Сложность

* Время: O(n·m).
* Память: O(1) дополнительной (помимо вывода).

### Крайние случаи / варианты

* Если нужно вернуть элементы как список в обратном порядке — аккумулировать в result (или проходить по линейному индексу `idx = n*m-1 downto 0`, вычисляя `i = idx / m, j = idx % m`).
* Для строчных/по-столбцам обходов можно поменять порядок циклов (внешний по столбцам, внутренний по строкам) в зависимости от нужного порядка.

---
