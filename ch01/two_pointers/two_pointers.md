## 1.  Целевая сумма инвестиций (Two Sum Closest)

**Суть:**
Найти два числа в отсортированном массиве, сумма которых ближе всего к заданной цели.

**Когда применять:**
Когда массив **уже отсортирован** и нужно быстро найти пару чисел с суммой, близкой к целевому значению.

**Пошаговый алгоритм:**

1. Установи `L = 0`, `R = N-1`.
2. Вычисли `sum = A[L] + A[R]`.
3. Если `|sum - target|` меньше текущей лучшей разницы — запомни её.
4. Если `sum < target` — увеличь `L` (хотим сумму больше).
5. Если `sum > target` — уменьши `R` (хотим сумму меньше).
6. Повторяй, пока `L < R`.

```
| Шаг                                          | L | R | A[L] | A[R] | Сумма | Разница к 10 | Движение |
| -------------------------------------------- | - | - | ---- | ---- | ----- | ------------ | -------- |
| 1                                            | 0 | 4 | -5   | 8    | 3     | 7            | ↑L       |
| 2                                            | 1 | 4 | 1    | 8    | 9     | 1            | ↑L       |
| 3                                            | 2 | 4 | 3    | 8    | 11    | 1            | ↓R       |
| 4                                            | 2 | 3 | 3    | 6    | 9     | 1            | ↑L       |
| **Результат:** сумма ближе всего к цели (9). |   |   |      |      |       |              |          |
```

---

## 2. Квадраты отсортированных значений (Sorted Squares)

**Суть:**
Получить отсортированный массив квадратов чисел (вход может содержать отрицательные).

**Когда применять:**
Когда массив **отсортирован, но содержит отрицательные значения**, и требуется получить квадраты — *в порядке возрастания*.

**Пошаговый алгоритм:**

1. Установи `L=0`, `R=N-1`, `W=N-1`.
2. Сравни `|A[L]|` и `|A[R]|`.
3. Больший квадрат запиши в `Result[W]`.
4. Сдвинь `L` или `R` в зависимости от того, кто был больше.
5. Уменьши `W`.
6. Повторяй, пока `L ≤ R`.

```
| Шаг | L | R | W | |A[L]| | |A[R]| | A[L]^2 | A[R]^2 | Запись |
|-----|---|---|---|--------|--------|--------|--------|--------|
| 1   | 0 | 4 | 4 | 4      | 10     | 16     | 100    | R→3    |
| 2   | 0 | 3 | 3 | 4      | 3      | 16     | 9      | L→1    |
| 3   | 1 | 3 | 2 | 1      | 3      | 1      | 9      | R→2    |
| 4   | 1 | 2 | 1 | 1      | 0      | 1      | 0      | L→2    |
| 5   | 2 | 2 | 0 | 0      | 0      | 0      | 0      | —      |
```
**Результат:** `[0, 1, 9, 16, 100]`

---

## 3.  Удаление дубликатов (Remove Duplicates In-Place)

**Суть:**
Удалить повторяющиеся элементы из отсортированного массива, не используя дополнительную память.

**Когда применять:**
Когда массив **отсортирован** и нужно удалить дубликаты **на месте** (in-place).

**Пошаговый алгоритм:**

1. Установи `W = 1` (позиция записи следующего уникального).
2. Для каждого `R` от `1` до `N-1`:

    * Если `A[R] != A[W-1]`, присвой `A[W] = A[R]` и увеличь `W`.
3. Возврати `W` — новую длину массива.

```
| W                                              | R | A[R] | Проверка | Действие        |
| ---------------------------------------------- | - | ---- | -------- | --------------- |
| 1                                              | 1 | 2    | =2       | Пропуск         |
| 1                                              | 2 | 3    | ≠2       | Записать A[1]=3 |
| 2                                              | 3 | 3    | =3       | Пропуск         |
| 2                                              | 5 | 5    | ≠3       | Записать A[2]=5 |
| 3                                              | 6 | 6    | ≠5       | Записать A[3]=6 |
| **Результат:** `[2, 3, 5, 6]` (новая длина 4). |   |      |          |                 |
```
---

## 4. Захват воды (Trapping Rain Water)

**Суть:**
Вычислить, сколько воды удержится между столбиками.

**Когда применять:**
Когда нужно посчитать "объём между стенками" — классическая задача на геометрию и баланс двух сторон.

**Пошаговый алгоритм:**

1. Установи L=0, R=N-1, MaxL=0, MaxR=0, water=0.
2. Пока L < R:
   - Если H[L] < H[R]:
      - Если H[L] >= MaxL: MaxL = H[L].
      - Иначе: добавить (MaxL - H[L]) к water.
      - L++.
   - Иначе:
      - Если H[R] >= MaxR: MaxR = H[R].
      - Иначе: добавить (MaxR - H[R]) к water.
      - R--.

```

| L                             | R   | MaxL | MaxR | Сравнение | Вода (новая) | Σ Воды |
| ----------------------------- | --- | ---- | ---- | --------- | ------------ | ------ |
| 0                             | 11  | 0    | 1    | 0<1       | 0            | 0      |
| 1                             | 11  | 1    | 1    | 1=1       | 0            | 0      |
| 1                             | 10  | 1    | 2    | 1<2       | 1            | 1      |
| 2                             | 10  | 1    | 2    | 1<2       | 0            | 1      |
| 3                             | 9   | 2    | 2    | 2=2       | 1            | 2      |
| ...                           | ... | ...  | ...  | ...       | ...          | ...    |
| **Результат:** 6 единиц воды. |     |      |      |           |              |        |
```
---

## 5. Сортировка чёт/нечёт (Stable Partition by Parity)

**Суть:**
Разделить массив на чётные и нечётные, сохранив порядок элементов.

**Когда применять:**
Когда важен **порядок** элементов и требуется быстрая сегрегация.

**Пошаговый алгоритм:**

1. Создай `Result=[]`.
2. Пройди по массиву — добавь все чётные.
3. Пройди второй раз — добавь все нечётные.

```
| Этап                                   | Действие                      | Result               |
| -------------------------------------- | ----------------------------- | -------------------- |
| 1                                      | Собираем чётные → 2, 4, 30    | [2, 4, 30]           |
| 2                                      | Добавляем нечётные → 11, 7, 1 | [2, 4, 30, 11, 7, 1] |
| **Результат:** `[2, 4, 30, 11, 7, 1]`. |                               |                      |

```

---

## 6. Сумма трёх компонентов (Three Sum)

**Идея:**
Используем сортировку + два указателя, чтобы найти уникальные тройки, сумма которых равна `target`.

```
| Параметр  | Значение                                     |
| --------- | ------------------------------------------- |
| Подход    | Сортировка + Два указателя                  |
| Сложность | O(N^2)                                      |
| Цель      | Найти все уникальные тройки, сумма = target |
```

**Пример:**
Массив = `[1,2,-1,-2,0]`, target = 0

```

| i | L | R | nums[i], nums[L], nums[R] | Сумма | Действие         |
| - | - | - | ------------------------- | ----- | ---------------- |
| 0 | - | - | 1,-2,2                    | 1     | < target → L++   |
| 0 | 1 | 3 | 1,-1,2                    | 2     | < target → L++   |
| 0 | 2 | 3 | 1,0,2                     | 3     | > target → R--   |
| 0 | 2 | 2 | —                         | —     | Завершение цикла |

```

**Результат:** уникальные тройки `[-2,0,2]`, `[-1,0,1]`

---

## 7. Обратный порядок регионов (Reverse Vowels)

**Идея:**
Используем два указателя: слева и справа, меняем только гласные.

```
| Параметр  | Значение                        |
| --------- | ------------------------------- |
| Подход    | Строки, два указателя            |
| Сложность | O(N)                             |
| Цель      | Перевернуть только гласные       |
```

**Пример:**
Строка = `"Helsinki"`

```
| L | R | Символы | Действие              | Строка       |
| - | - | ------- | --------------------- | ------------ |
| 0 | 7 | H,K     | Не гласные → L++, R-- | `"Helsinki"` |
| 1 | 6 | e,i     | Меняем местами        | `"Hilsenke"` |
| 2 | 5 | l,n     | Не гласные → L++, R-- | `"Hilsenke"` |

```
**Результат:** `"Hilsenke"`

---

## 8. Удаление старых версий (Remove Element In-Place)

**Идея:**
Используем write-index, чтобы сдвинуть все элементы != val в начало.

```
| Параметр  | Значение                        |
| --------- | ------------------------------- |
| Подход    | Массивы, write index            |
| Сложность | O(N)                             |
| Цель      | Удалить все вхождения val        |
```

**Пример:**
Массив = `[3,2,2,3]`, val = 3

```
| W | R | A[R] | Действие        | Массив    |
| - | - | ---- | --------------- | --------- |
| 0 | 0 | 3    | равно val → R++ | [3,2,2,3] |
| 0 | 1 | 2    | A[W]=2, W++     | [2,2,2,3] |
| 1 | 2 | 2    | A[W]=2, W++     | [2,2,2,3] |
| 2 | 3 | 3    | равно val → R++ | [2,2,2,3] |

```
**Результат:** `[2,2]`

---

## 9. Сжатие данных (String Compression)

**Идея:**
Считаем серии одинаковых символов, записываем `<кол-во><символ>`.

```
| Параметр  | Значение                        |
| --------- | ------------------------------- |
| Подход    | Два указателя / подсчёт серий    |
| Сложность | O(N)                             |
| Цель      | Сжать строку                      |
```

**Пример:**
Строка = `"AAAAB"`

```
| L | R | Символ | Счётчик | Действие    | Результат |
| - | - | ------ | ------- | ----------- | --------- |
| 0 | 0 | A      | 1       | R++         |           |
| 0 | 1 | A      | 2       | R++         |           |
| 0 | 3 | A      | 4       | R++         |           |
| 0 | 4 | B      | 1       | Записать 4A | 4A        |
| 4 | 4 | B      | 1       | Записать 1B | 4A1B      |
```
---

## 10. Поиск медианы двух отсортированных баз (Median of Two Sorted Arrays)

**Задача:**
Даны два отсортированных массива `A` и `B`. Нужно найти медиану объединённого массива **без фактического объединения**.

**Идея:**
Используем **бинарный поиск по меньшему массиву**, ищем правильное разбиение массивов:

* Разделяем массивы так, чтобы **все элементы левой части ≤ всех элементов правой части**.
* Если условие выполняется, медиана = среднее двух средних элементов (или средний элемент, если суммарная длина нечётная).

---

### Пошаговое решение

**Пример:**
`A = [1,3]`, `B = [2]`

**Шаг 0. Подготовка**

* Выбираем меньший массив для бинарного поиска → `A` (длина 2)
* Определяем: `total_len = len(A)+len(B) = 3` (нечётное)
* Целевая левая половина = `(total_len+1)//2 = 2` элементов

---

**Шаг 1. Бинарный поиск по A**

* `left = 0`, `right = len(A) = 2`
* Берём середину: `i = (left+right)//2 = 1`
* Левый разрез в B: `j = target_left - i = 2 - 1 = 1`

**Проверяем условия:**

* `A[i-1] <= B[j]` → `A[0]=1 <= B[1]=∞` (не выходит за границы)
* `B[j-1] <= A[i]` → `B[0]=2 <= A[1]=3` ok

---

**Шаг 2. Находим медиану**

* Поскольку `total_len` нечётное, медиана = `max(A[i-1], B[j-1])`
* `A[i-1] = 1`, `B[j-1] = 2` → `max(1,2) = 2`

**Результат:** медиана = **2**

---

### Таблица пошаговых проверок
```
| Шаг | i (A) | j (B) | A[i-1] | A[i] | B[j-1] | B[j] | Условие A[i-1]≤B[j] | Условие B[j-1]≤A[i] | Разрез корректен? | Медиана |
| --- | ----- | ----- | ------ | ---- | ------ | ---- |---------------------|---------------------| ----------------- | ------- |
| 1   | 1     | 1     | 1      | 3    | 2      | ∞    | 1 ≤ ∞ ok            | 2 ≤ 3 ok            | Да                | 2       |
```

> Примечание: Используем ±∞, если индекс выходит за границу массива.

---

### Общий алгоритм

1. Выбираем меньший массив для бинарного поиска.
2. Определяем левую половину: `(len(A)+len(B)+1)//2`.
3. Делаем бинарный поиск по индексу `i` в массиве `A`.
4. Вычисляем `j = target_left - i`.
5. Проверяем условия:

    * `A[i-1] ≤ B[j]` и `B[j-1] ≤ A[i]`
6. Если условия не выполняются, сдвигаем `i`:

    * Если `A[i-1] > B[j]` → сдвигаем `right = i-1`
    * Иначе → `left = i+1`
7. Когда разрез найден, медиана:

    * **Нечётная длина:** `max(A[i-1], B[j-1])`
    * **Чётная длина:** `(max(A[i-1], B[j-1]) + min(A[i], B[j])) / 2`

---


## 11. Парковка (Two-Side Matching)

**Идея:**
Сортируем размеры парковочных мест и машин, используем два указателя `i` и `j`, жадно ставим машины на подходящие места.

**Пример:**
Места = `[2,3,4]`, Машины = `[1,3,4]`

```

| i (место) | j (машина) | Место | Машина | Действие              | Размещено |
| --------- | ---------- | ----- | ------ | --------------------- | --------- |
| 0         | 0          | 2     | 1      | 1 ≤ 2 → ставим машину | 1         |
| 1         | 1          | 3     | 3      | 3 ≤ 3 → ставим машину | 2         |
| 2         | 2          | 4     | 4      | 4 ≤ 4 → ставим машину | 3         |

```

**Результат:** Максимум машин = **3**

---

## 12. Оптимизация долга/актива

**Идея:**
Сортируем должников и кредиторов, используем два указателя, подбираем пары с минимальной разницей.

**Пример:**
Должники = `[1,3,5]`
Кредиторы = `[2,6]`

```

| i (должник) | j (кредитор) | Долг | Кредит | Разница | Действие       | Пары  |
| ----------- | ------------ | ---- | ------ | ------- | -------------- | ----- |
| 0           | 0            | 1    | 2      | 1       | 1≤2 → пара     | (1,2) |
| 1           | 1            | 3    | 6      | 3       | 3≤6 → пара     | (3,6) |
| 2           | —            | 5    | —      | —       | нет кредиторов | —     |

```

**Результат:** Пары = `(1,2), (3,6)`

---

## 13. Корректировка палиндрома

**Идея:**
Два указателя слева/справа, игнорируем пробелы и неалфавитные символы, сравниваем буквы.

**Пример:**
Строка = `"A man, a plan, a canal, Panama"`

```

| L  | R  | Символы | Действие        | Комментарий                 |
| -- | -- | ------- | --------------- | --------------------------- |
| 0  | 29 | A,P     | A==A → L++, R-- | Сравниваем буквы            |
| 1  | 28 | ,a      | пропускаем ','  | Нужен алфавит/цифра         |
| 2  | 27 | m,m     | m==m → L++, R-- | Продолжаем сравнивать       |
| …  | …  | …       | …               | …                           |
| 14 | 15 | a,a     | a==a → L++, R-- | Достигли центра → палиндром |

```

**Результат:** Строка является палиндромом 

---

## 14. Нахождение пары с близкой суммой

**Идея:**
Отсортированный массив, два указателя (`L` слева, `R` справа). Выбираем пару с суммой, ближайшей к `target`.

**Пример:**
Массив = `[1,2,3,4,5]`, target = 8

```
| L | R | nums[L]+nums[R] | Сумма | Разница | Действие      |
| - | - | --------------- | ----- | ------- | ------------- |
| 0 | 4 | 1+5=6           | 6     | 2       | <target → L++ |
| 1 | 4 | 2+5=7           | 7     | 1       | <target → L++ |
| 2 | 4 | 3+5=8           | 8     | 0       | нашли exact   |
```

**Результат:** Пара = `(3,5)`, сумма = **8**

---

## 15. Разделение положительных/отрицательных

**Идея:**
Два указателя: `L` — позиция для следующего отрицательного, `R` — текущий элемент. Меняем местами отрицательные и положительные, чтобы все отрицательные были слева.

**Пример:**
Массив = `[1,-2,3,-4,5]`

```
| L | R | A[R] | Действие                 | Массив после шага |
| - | - | ---- | ------------------------ | ----------------- |
| 0 | 0 | 1    | >0 → R++                 | [1,-2,3,-4,5]     |
| 0 | 1 | -2   | swap(A[L],A[R]), L++,R++ | [-2,1,3,-4,5]     |
| 1 | 2 | 3    | >0 → R++                 | [-2,1,3,-4,5]     |
| 1 | 3 | -4   | swap(A[L],A[R]), L++,R++ | [-2,-4,3,1,5]     |
| 2 | 4 | 5    | >0 → R++                 | [-2,-4,3,1,5]     |

```
**Результат:** Все отрицательные слева → `[-2,-4,3,1,5]`

---

```

go run main.go

```