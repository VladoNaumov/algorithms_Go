### Задачи и данные

#### 1. **Максимальная прибыль (одна сделка)**
**Описание**: Дан массив цен акций за дни. Найдите максимальную прибыль, которую можно получить, купив акцию в один день и продав в другой (позже). Если прибыль невозможна, верните 0.  
**Входные данные**:
- prices = [7, 1, 5, 3, 6, 4]
- prices = [7, 6, 4, 3, 1]  
  **Ограничения**: Массив не пустой, цены — целые числа.

**Как решать:**

1. Идём по ценам слева направо.
2. Запоминаем минимальную цену (лучшую для покупки).
3. На каждом шаге считаем возможную прибыль, если продать сегодня.
4. Если прибыль больше текущего максимума — обновляем.
5. В конце максимальная прибыль — это ответ.
   Если цены только падают, прибыль = 0.

**Пример:**
[7, 1, 5, 3, 6, 4]
→ минимум 1, максимум прибыли = 6 − 1 = **5** (купили по 1, продали по 6).

---

#### 2. **Анализ баланса (Кадане)**
**Описание**: Дан массив ежедневных изменений баланса счёта (положительные или отрицательные). Найдите максимальную сумму дохода за любой непрерывный период.  
**Входные данные**:
- changes = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
- changes = [1, -2, -3, -4]  
  **Ограничения**: Массив не пустой, элементы — целые числа.

**Как решать:**

1. Начинай с суммы = 0.
2. На каждом шаге добавляй число к текущей сумме.
3. Если сумма становится отрицательной — обнуляй (начинай новый период).
4. Сохраняй максимальную сумму, которую встретил.

**Пример:**
[-2, 1, -3, 4, -1, 2, 1, -5, 4]
→ лучший участок [4, -1, 2, 1] = **6**.

---


#### 3. **Сортировка по категориям (Dutch Flag)**
**Описание**: Дан массив заказов с приоритетами (0 — высокий, 1 — средний, 2 — низкий). Отсортируйте массив так, чтобы приоритеты шли в порядке 0, 1, 2.  
**Входные данные**:
- orders = [2, 0, 1, 0, 2, 1]
- orders = [1, 1, 2, 0, 0, 2]  
  **Ограничения**: Элементы массива — только 0, 1 или 2.

**Как решать:**

1. Можно посчитать, сколько каждого значения.
2. Или использовать три указателя:

* начало для 0,
* конец для 2,
* середина — проход по массиву.
3. Меняй элементы, чтобы 0 были впереди, 2 — сзади.

**Пример:**
[2, 0, 1, 0, 2, 1] → [0, 0, 1, 1, 2, 2]

---


#### 4. **Сдвиг данных (Ротация логов)**
**Описание**: Дан массив логов. Поверните его на K позиций вправо (циклически).  
**Входные данные**:
- logs = [1, 2, 3, 4, 5], K = 2
- logs = [3, 2, 1], K = 1  
  **Ограничения**: K ≥ 0, массив не пустой.

**Как решать:**

1. Делим массив на две части:

* хвост (последние K),
* остальное.
2. Меняем их местами.
3. Если K больше длины — используем K % длина.

**Пример:**
[1, 2, 3, 4, 5], K=2 → [4, 5, 1, 2, 3]

---

#### 5. **Пропущенный платёж**
**Описание**: Дан массив платежей с числами от 1 до N, где один платёж пропущен. Найдите пропущенное число.  
**Входные данные**:
- payments = [3, 1, 4, 2, 6, 5]
- payments = [1, 2, 4]  
  **Ограничения**: Массив содержит числа от 1 до N, одно число отсутствует.

**Как решать:**

1. Посчитай ожидаемую сумму всех чисел: `N * (N + 1) / 2`.
2. Найди реальную сумму массива.
3. Разница = пропущенное число.

**Пример:**
[1, 2, 4] → сумма(1..4)=10, реальная=7 → пропущено **3**.

---


#### 6. **Единственный сотрудник**
**Описание**: Дан массив ID сотрудников, где каждый ID, кроме одного, встречается дважды. Найдите ID, встречающийся один раз.  
**Входные данные**:
- ids = [7, 3, 5, 3, 5, 7, 4]
- ids = [2, 2, 1]  
  **Ограничения**: Массив содержит нечётное количество элементов.

**Как решать:**

1. Сравнивай все элементы — тот, кто не имеет пары, и есть ответ.
2. Или можно использовать XOR — он “гасит” одинаковые пары.

**Пример:**
[7, 3, 5, 3, 5, 7, 4] → уникальный **4**.

---

#### 7. **Продукт конкурентов**
**Описание**: Дан массив чисел. Для каждого элемента i вычислите произведение всех остальных элементов (без деления).  
**Входные данные**:
- nums = [1, 2, 3, 4]
- nums = [2, 3, 5]  
  **Ограничения**: Массив не пустой, деление использовать нельзя.

**Как решать:**

1. Сначала найди произведения слева (до элемента).
2. Потом справа (после элемента).
3. Перемножь левое и правое для каждого индекса.

**Пример:**
[1, 2, 3, 4] → [24, 12, 8, 6]

---

#### 8. **Максимальная последовательная убыль цен**
**Описание**: Дан массив цен за дни. Найдите максимальное количество последовательных дней, когда цена падала.  
**Входные данные**:
- prices = [5, 4, 3, 4, 3, 2, 1]
- prices = [1, 2, 3, 2, 1]  
  **Ограничения**: Массив не пустой, цены — целые числа.

**Как решать:**

1. Счётчик текущей убыли = 0.
2. Если цена сегодня меньше вчерашней — +1.
3. Если нет — сброс счётчика.
4. Запоминай максимальный результат.

**Пример:**
[5, 4, 3, 4, 3, 2, 1] → максимальная серия = **3** (4 → 3 → 2 → 1).

---

#### 9. **Сдвиг неактивных пользователей**
**Описание**: Дан массив, где 0 — неактивные пользователи, остальные — активные. Переместите все 0 в конец, сохранив порядок активных.  
**Входные данные**:
- users = [1, 0, 2, 0, 3, 4]
- users = [0, 0, 1, 2]  
  **Ограничения**: Массив содержит 0 и положительные числа.

**Как решать:**

1. Пройди массив, записывая активных пользователей в начало.
2. После них заполни нулями.

**Пример:**
[1, 0, 2, 0, 3, 4] → [1, 2, 3, 4, 0, 0]

---


#### 10. **Рейтинг популярности товара**
**Описание**: Дан массив оценок товара (от 1 до 5). Найдите 3 наиболее часто встречающиеся оценки (в порядке убывания частоты).  
**Входные данные**:
- ratings = [1, 2, 2, 3, 3, 3, 4, 4, 5]
- ratings = [5, 5, 5, 4, 4, 3]  
  **Ограничения**: Массив не пустой, оценки от 1 до 5.

**Как решать:**

1. Подсчитай, сколько раз встречается каждая оценка.
2. Отсортируй по частоте (по убыванию).
3. Возьми три первых.

**Пример:**
[1, 2, 2, 3, 3, 3, 4, 4, 5] → самые частые: [3, 2, 4]

---


#### 11. **Баланс транзакций**
**Описание**: Дан массив транзакций (положительные или отрицательные). Найдите день с минимальным накопленным балансом.  
**Входные данные**:
- transactions = [7, -3, -10, 4, 2, 8]
- transactions = [-2, -3, -4]  
  **Ограничения**: Массив не пустой, элементы — целые числа.

**Как решать:**

1. Считай накопленный баланс по дням (прибавляй каждую транзакцию).
2. Следи, когда баланс минимальный.

**Пример:**
[7, -3, -10, 4, 2, 8] → накопленные [7, 4, -6, -2, 0, 8] → минимум **-6** (3-й день).

---

#### 12. **Проверка контрольной суммы (ISBN)**
**Описание**: Дана строка ISBN-10 (10 цифр). Проверьте, является ли контрольная сумма корректной (сумма произведений цифр на их позиции, делённая на 11, даёт остаток 0).  
**Входные данные**:
- isbn = "0321146530"
- isbn = "0131103628"  
  **Ограничения**: Строка содержит 10 цифр.


**Как решать:**

1. Каждую цифру умножь на её позицию (от 1 до 10).
2. Сложи всё.
3. Если сумма % 11 == 0 → ISBN правильный.

**Пример:**
"0131103628" → корректный ISBN.

---

#### 13. **Поиск пиковой нагрузки**
**Описание**: Дан массив потребления энергии. Найдите пиковый элемент (больше своих соседей).  
**Входные данные**:
- energy = [1, 2, 3, 1, 4, 2]
- energy = [1, 2, 1]  
  **Ограничения**: Массив имеет длину ≥ 3, пиковый элемент существует.

**Как решать:**

1. Идём по массиву.
2. Проверяем каждый элемент: больше ли он обоих соседей.
3. Первый найденный пик можно вернуть.

**Пример:**
[1, 2, 3, 1, 4, 2] → пики 3 и 4 (можно вернуть любой).

---



#### 14. **Самая длинная серия побед/поражений**
**Описание**: Дан массив результатов (1 — победа, 0 — поражение). Найдите длину самой длинной последовательности одинаковых результатов.  
**Входные данные**:
- results = [1, 1, 0, 0, 0, 1, 1]
- results = [0, 1, 0, 1]  
  **Ограничения**: Массив содержит только 0 и 1.

**Как решать:**

1. Идём по массиву, считаем подряд идущие одинаковые.
2. Если результат меняется — сбрасываем счётчик.
3. Запоминаем максимум.

**Пример:**
[1, 1, 0, 0, 0, 1, 1] → самая длинная серия = **3** (три поражения подряд).

---

#### 15. **Проверка уникальности ID**
**Описание**: Дан массив ID клиентов. Проверьте, есть ли в нём дубликаты.  
**Входные данные**:
- ids = [1, 2, 3, 4]
- ids = [1, 2, 2, 3]  
  **Ограничения**: Массив не пустой, ID — целые числа.

**Как решать:**

1. Проходи по списку и запоминай все ID.
2. Если встретил ID, который уже был — значит, есть дубликат.
3. Если ни разу не повторился — все уникальны.

**Пример:**
[1, 2, 2, 3] → повтор **2** → не уникально.

---

## 16. **Максимальная сумма фиксированного окна (sliding window max sum)**

**Условие:**
Дан массив чисел и число `k`. Найти максимальную сумму подряд идущих `k` элементов.

**Почему полезно:**
Найти лучший период фиксированной длины (например, за k дней) — часто нужно в аналитике.

**Как решать (шаги):**

1. Считаем сумму первых `k` элементов — это начальная сумма `currentSum`.
2. Дальше двигаем окно на один шаг вправо: вычитаем из `currentSum` элемент, который выходит из окна (левый), и добавляем элемент, который входит (правый).
3. После каждого сдвига сравниваем `currentSum` с `bestSum` и обновляем `bestSum`, если текущая сумма больше.
4. Продолжаем, пока окно умещается в массиве.
5. Ответ — `bestSum`.

**Пример:**
`nums = [2, 3, 5, 2, 1, 4], k = 3`
Окна: `[2,3,5]=10`, `[3,5,2]=10`, `[5,2,1]=8`, `[2,1,4]=7` → максимум **10**.

**Сложность:**
Время O(n), память O(1).

---

## 17. **Слияние двух отсортированных массивов (в один отсортированный) — in-place**

**Условие:**
Даны два массива, оба отсортированы по возрастанию. Первый массив имеет достаточно места в конце, чтобы вместить второй. Нужно объединить их в один отсортированный массив в первом (без создания большого вспомогательного массива).

**Почему полезно:**
Практически при объединении результатов двух источников без лишней памяти.

**Как решать (шаги):**

1. Рассмотрим индексы: `i` — последний элемент реальных значений в первом массиве, `j` — последний элемент второго массива, `pos` — позиция для записи (конец первого массива).
2. Сравниваем элементы с концов: если `first[i] > second[j]`, записываем `first[i]` в `first[pos]` и уменьшаем `i`; иначе — записываем `second[j]` и уменьшаем `j`.
3. Двигаем `pos` назад после каждой записи.
4. Когда один из массивов заканчивается, оставшиеся элементы другого уже на месте (если это второй — скопировать оставшиеся).
5. В результате весь массив `first` будет содержать все элементы в порядке.

**Пример:**
`first = [1,3,5,0,0,0]` (три «0» — место), `second = [2,4,6]` → после слияния `first = [1,2,3,4,5,6]`.

**Сложность:**
Время O(m + n), память O(1).

---

## 18. **Мажоритарный элемент (> n/2) — Boyer-Moore**

**Условие:**
В массиве есть элемент, который встречается **строго больше n/2 раз**. Нужно найти этот элемент.

**Почему полезно:**
Позволяет быстро найти «главный» элемент без хеш-таблиц.

**Как решать (шаги):**

1. Поддерживаем два значения: кандидат `candidate` и счётчик `count`.
2. Проходим массив: если `count` = 0 → устанавливаем `candidate` = текущий элемент и `count` = 1.
3. Если текущий элемент равен `candidate` → `count++`, иначе `count--`.
4. В конце `candidate` — потенциальный мажоритарный элемент. При необходимости можно пройти ещё раз и подтвердить, что он действительно встречается > n/2 (в задачах часто гарантируют его существование).
5. Интуиция: пары разных элементов «взаимно уничтожаются», остаётся тот, кто в большинстве.

**Пример:**
`[2,2,1,1,1,2,2]` → мажоритарный **2**.

**Сложность:**
Время O(n), память O(1).

---

## 19. **Количество подмассивов с суммой равной k (подмассивы с заданной суммой)**

**Условие:**
Дан массив целых чисел (могут быть отрицательные) и число `k`. Найти **количество непрерывных подмассивов**, сумма которых равна `k`.

**Почему полезно:**
Нахождение количества периодов с точной суммой — важная аналитическая задача.

**Как решать (шаги):**

1. Будем использовать префикс-суммы и карту (словарь) частот префикс-сумм.
2. Поддерживаем `prefixSum` — сумму элементов от начала до текущего индекса.
3. Для текущей позиции хотим знать, сколько предыдущих префикс-сумм `prev` такое, что `prefixSum - prev = k` ⇒ `prev = prefixSum - k`.
4. Значит, в словаре ищем `prefixSum - k` и добавляем его частоту к ответу (это число подмассивов, которые заканчиваются в текущем индексе и дают сумму k).
5. Обновляем частоту `prefixSum` в словаре и идём дальше.
6. Инициализируем словарь с `{0:1}` (пустой префикс учитываем).

**Пример:**
`nums = [1, 1, 1], k = 2` → подмассивы: `[1,1]` (начиная с 0 и 1) → **2**.

**Сложность:**
Время O(n), память O(n).

---

## 20. **Найти повторяющееся число (в массиве 1..n, один дубль), методом поиска цикла (Floyd)**

**Условие:**
Дан массив длины `n+1`, содержащий числа от `1` до `n`. В массиве есть **ровно одно число**, которое повторяется ≥2 раз. Нужно найти это повторение, не меняя массив и с O(1) дополнительной памяти.

**Почему полезно:**
Это хитрая задача — связана с представлением массива как ссылок/следов, где повторение создаёт цикл.

**Как решать (шаги, идея):**

1. Интерпретируем массив как функцию перехода: индекс → значение (т.е. из позиции i переходим к a[i]). Это создаёт формально «связный список», в котором обязательно есть цикл из-за повторяющегося значения.
2. Используем алгоритм «черепаха и заяц» (Floyd’s Tortoise and Hare):

  * `slow` двигается на 1 шаг (slow = a[slow]),
  * `fast` двигается на 2 шага (fast = a[a[fast]]).
3. Они встретятся внутри цикла.
4. Затем начинаем второй этап: ставим `ptr1` в начало (0 или первый индекс, в зависимости от реализации), `ptr2` в точку встречи; двигаем оба по одному шагу — место пересечения будет началом цикла, а значение этого индекса — повторяющееся число.
5. Возвращаем найденное число.

**Пример:**
`[3,1,3,4,2]` (индексы 0..4) → повтор **3**.

**Сложность:**
Время O(n), память O(1).

---

go run main.go

---

