### Матрицы (итерационные решения, без рекурсии).

### 1. **Спиральный обход склада**

### Представь, что у тебя **коробка с конфетами**, разложенными в сетку 4×4.

```
┌───┬───┬───┬───┐
│ A │ B │ C │ D │
├───┼───┼───┼───┤
│ E │ F │ G │ H │
├───┼───┼───┼───┤
│ I │ J │ K │ L │
├───┼───┼───┼───┤
│ M │ N │ O │ P │
└───┴───┴───┴───┘
```

Ты хочешь **съесть все конфеты по спирали**:  
сначала внешний круг → потом следующий → и так до центра.

---

### Как ты это делаешь?

Ты **всегда идёшь по краю текущего прямоугольника**, и каждый раз, когда прошёл одну сторону — **съедаешь её и убираешь из игры**.

---

### Шаг 1: Ешь внешний круг

1. **Слева направо по верху** → A, B, C, D  
   → **Верхняя строка съедена!** → больше не трогаем строку 0.

2. **Сверху вниз по правому краю** → H, L, P  
   → **Правый столбец съеден!** → больше не трогаем столбец 3.

3. **Справа налево по низу** → O, N, M  
   → **Нижняя строка съедена!** → больше не трогаем строку 3.

4. **Снизу вверх по левому краю** → I, E  
   → **Левый столбец съеден!** → больше не трогаем столбец 0.

---

### Шаг 2: Ешь внутренний прямоугольник

1. **Слева направо по верху** → F, G  
   → **Верхняя строка съедена!**

2. **Сверху вниз по правому краю** → K  
   → **Правый столбец съеден!**

3. **Справа налево по низу** → J  
   → **Нижняя строка съедена!**

4. **Снизу вверх по левому краю** → **ничего не осталось** (уже всё съедено)

---

### Главная идея — **четыре границы**

Представь, что у тебя **четыре стены**, которые сжимаются внутрь:

| Стена | Что делает |
|------|------------|
| **Верхняя** (`top`) | После прохода по ней — поднимается на 1 |
| **Нижняя** (`bottom`) | После прохода по ней — опускается на 1 |
| **Левая** (`left`) | После прохода по ней — сдвигается вправо |
| **Правая** (`right`) | После прохода по ней — сдвигается влево |

Пока **верхняя стена не пересеклась с нижней** и **левая не пересеклась с правой** — ты можешь пройти ещё один круг.

---

### Пошагово — что происходит с границами

| Этап | top | bottom | left | right | Что проходим |
|------|-----|--------|------|-------|--------------|
| Начало | 0 | 3 | 0 | 3 | Внешний круг |
| После 1-го круга | 1 | 2 | 1 | 2 | Внутренний 2×2 |
| После 2-го круга | 2 | 1 | 2 | 1 | Границы пересеклись → конец |

---

Это **всегда один и тот же порядок**:
1. Вперёд по верху
2. Вниз по правому краю
3. Назад по низу
4. Вверх по левому краю

---

### Пример: 3×3 — покажи, как работает

```
1 2 3
4 5 6
7 8 9
```

1. `top=0` → 1,2,3 → `top=1`
2. `right=2` → 6,9 → `right=1`
3. `bottom=2` → 8,7 → `bottom=1`
4. `left=0` → 4 → `left=1`

Осталось: `5` в центре.

→ Цикл снова:  
`top=1`, `bottom=1`, `left=1`, `right=1` → берём `5` → конец.

**Результат:** `1,2,3,6,9,8,7,4,5`

---
**Готово.**
---

## 2. Поворот изображения на 90° по часовой стрелке (in-place)

### Представь: у тебя **картинка из квадратиков**, как мозаика 3×3:

```
1 2 3
4 5 6
7 8 9
```

Ты хочешь **повернуть её на 90° по часовой стрелке**, как будто крутишь лист бумаги.

### Результат должен быть:
```
7 4 1
8 5 2
9 6 3
```

---

### Как это сделать **без новой картинки**? (in-place)

### Способ 1: **"Перевернуть по диагонали, потом по горизонтали"**

#### Шаг 1: **Транспонирование** — поменять строки и столбцы

> Представь, что ты **переворачиваешь картинку по главной диагонали** (от верхнего лева к нижнему праву).

```
1 2 3     →     1 4 7
4 5 6           2 5 8
7 8 9           3 6 9
```

→ `1` остаётся, `2` ↔ `4`, `3` ↔ `7`, `6` ↔ `8` и т.д.

#### Шаг 2: **Перевернуть каждую строку слева направо**

```
1 4 7     →     7 4 1
2 5 8     →     8 5 2
3 6 9     →     9 6 3
```

**Готово!**  
Ты повернул картинку на 90° по часовой стрелке — **без лишней бумаги**.

---

### Способ 2: **"Крутить по кольцам"** (как спираль, но наоборот)

> Представь, что картинка — **луковица**. У неё есть **слои**:

- Внешний слой: `1,2,3,6,9,8,7,4`
- Внутренний слой: только `5`

#### Как крутить внешний слой?

Берёшь **4 угла** и **крутишь их по часовой стрелке**:

```
1 → 3 → 9 → 7 → 1
```

То есть:
- `1` → место `3`
- `3` → место `9`
- `9` → место `7`
- `7` → место `1`

Аналогично для **серединок сторон**:
- `2` → `6` → `8` → `4` → `2`

Делаешь это **для каждого слоя**, пока не дойдёшь до центра.

---

### Картинка-шпаргалка

```
Крутить по часовой:
1 → 3 → 9 → 7 → 1
2 → 6 → 8 → 4 → 2
```

→ Внешний слой → внутренний → центр (ничего не крутим).

---

### А если 1×1 или 2×2?

- `5` → остаётся на месте.
- 2×2:
  ```
  a b
  c d
  ```
  → после поворота:
  ```
  c a
  d b
  ```

---

## 3. Установка нулей (если есть 0 — обнулить строку и столбец)

### Представь: у тебя **таблица оценок**, и если кто-то получил **0**, то **вся его строка и весь столбец — провал!**

```
1 2 3 4
5 0 7 8
9 1 2 3
```

→ Потому что есть `0` во второй строке, третьем столбце →  
**вся 2-я строка и весь 3-й столбец — нули!**

Результат:
```
1 0 0 4
0 0 0 0
9 0 0 3
```

---

### Как сделать **без лишней памяти**?

### Идея: **использовать первую строку и первый столбец как "флажки"**

> Представь, что:
> - **Первая строка** — это **индикатор: "эта колонка плохая?"**
> - **Первый столбец** — **индикатор: "эта строка плохая?"**

#### Шаг 1: Пройди по таблице и **поставь метки**

- Видишь `0` в `A[1][1]` → поставь `0` в `A[1][0]` (строка плохая) и `A[0][1]` (столбец плохой)

#### Шаг 2: Пройди по внутренней части и **обнули, где метка**

- Если `A[i][0] == 0` или `A[0][j] == 0` → `A[i][j] = 0`

#### Шаг 3: Обнули **первую строку и первый столбец**, если нужно

- Были ли нули в первой строке изначально? → обнули её
- Были ли в первом столбце? → обнули его

---

### Картинка

```
    ← столбцы →
    0 1 2 3
  0 x x x x   ← первая строка
  1 x
  2 x
  3 x
  ↑
  первый
  столбец
```

→ `x` — место для меток

---

### А если 0 в первом столбце или строке?

→ Сохраняем **отдельные флажки**:  
`first_row_has_zero = да/нет`  
`first_col_has_zero = да/нет`

---

## 4. Проход по диагоналям (по сумме i+j)

### Представь: ты **читаешь таблицу по диагоналям**, как в зигзаге

```
1 2 3
4 5 6
7 8 9
```

→ Хочешь вывести:  
`1 → 2,4 → 3,5,7 → 6,8 → 9`

То есть **группы по сумме индексов**:
- `i+j=0`: `1`
- `i+j=1`: `2,4`
- `i+j=2`: `3,5,7`
- и т.д.

---

### Как это представить?

> Каждая диагональ — это **все ячейки, где сумма строки и столбца одинаковая**

```
(0,0) → сумма 0
(0,1) и (1,0) → сумма 1
(0,2), (1,1), (2,0) → сумма 2
...
```

---

### Порядок: **сначала маленькие суммы, потом большие**

→ Начинаешь с `s = 0`, потом `s = 1`, ..., до `s = n+m-2`

Для каждой `s`:
- Берёшь все `i`, где `j = s - i` — в пределах таблицы

---

### Картинка

```
Диагональ s=2:
(0,2)=3
(1,1)=5
(2,0)=7
```

→ Идёшь **сверху вниз** или **снизу вверх** — зависит от задачи.

---

## 5. Усреднение по 3×3 окну (тепловая карта)

### Представь: у тебя **карта температуры**, и ты хочешь **сгладить её**

```
10 20 30
40 50 60
70 80 90
```

→ Для каждой ячейки — берёшь **её и 8 соседей**, считаешь **среднее**

---

## Пример: центр `50`

Соседи:
```
40 50 60
?  50  ?
70 80 90
```

→ Берём только существующие: `40,50,60,70,80,90` → 6 чисел → среднее = `65`

---

Конечно! Ниже — **все оставшиеся 20 задач** (с 6 по 25) в **том же духе**:
- **Без кода, без псевдокода**
- **Просто, как для ребёнка**
- **С картинками, аналогиями, шпаргалками**
- **Итерационно, без рекурсии**
- **С пошаговыми примерами на 3×3 или 2×2**

---

## 6. Проверка судоку (9×9)

### Представь: ты — **детектив** в мире чисел.
У тебя **таблица 9×9**, и в ней **никаких повторов** в:

- строках
- столбцах
- маленьких квадратах 3×3

```
5 3 . | . 7 . | . . .
6 . . | 1 9 5 | . . .
. 9 8 | . . . | . 6 .
------+-------+------
8 . . | . 6 . | . . 3
4 . . | 8 . 3 | . . 1
7 . . | . 2 . | . . 6
------+-------+------
. 6 . | . . . | 2 8 .
. . . | 4 1 9 | . . 5
. . . | . 8 . | . 7 9
```

---

## Как проверить?

> **Три правила — три проверки**:

1. **Каждая строка** — числа 1–9, **без повторов**
2. **Каждый столбец** — то же самое
3. **Каждый квадратик 3×3** — тоже 1–9, без повторов

---

## Как делать?

> **Представь три блокнота**:

| Блокнот | Что записываешь |
|--------|------------------|
| Строки | "В строке 0 уже есть 5? Да → нельзя ещё раз!" |
| Столбцы | "В столбце 1 уже есть 3? Да → ошибка!" |
| Квадраты | "В квадрате [0,0] уже есть 6? Да → стоп!" |

→ Проходишь по **всем ячейкам**.  
→ Для каждой ячейки:
- Проверяешь **три блокнота**
- Если число уже есть → **судоку сломано!**

---

## Картинка

```
┌───┬───┬───┐
│ 1 │ 2 │ 3 │ ← квадрат [0,0]
├───┼───┼───┤
│ 4 │ 5 │ 6 │
├───┼───┼───┤
│ 7 │ 8 │ 9 │
└───┴───┴───┘
```

→ Если в этом квадрате **два 5** → **ошибка!**

---

# 7. Самая большая область 1 (через гистограмму)

## Представь: у тебя **карта из 0 и 1**, как пиксели:

```
0 1 1 0
1 1 1 1
1 0 1 1
1 1 1 1
```

→ Хочешь найти **самый большой прямоугольник из одних 1**

---

## Как?

> **Представь, что смотришь на карту сверху вниз, как на здание**

Каждая строка — **новый этаж**.  
Если внизу была 1, а сверху тоже 1 → **высота растёт**.

```
Строка 0: 0 1 1 0 → высота: [0,1,1,0]
Строка 1: 1 1 1 1 → высота: [1,2,2,1]
Строка 2: 1 0 1 1 → высота: [2,0,3,2]
Строка 3: 1 1 1 1 → высота: [3,1,4,3]
```

→ На каждой строке — **гистограмма высот**

---

## А теперь — **ищи самый большой прямоугольник в гистограмме**

> Используешь **стек**, как линейку:
- Кладешь столбцы по одному
- Если текущий **ниже предыдущего** → "срезаешь" выступ
- Считаешь **площадь** = высота × ширина

---

## Картинка

```
Строка 3: высоты [3,1,4,3]

    █
    █   █
    █ █ █ █
    █ █ █ █
    3 1 4 3
```

→ Самый большой: высота 3, ширина 4 → **площадь 12**

---

# 8. Зеркальное отражение (по вертикали)

## Представь: у тебя **фото**, и ты **переворачиваешь его по вертикали**

```
1 2 3     →     3 2 1
4 5 6     →     6 5 4
7 8 9     →     9 8 7
```

---

## Как?

> **Каждая строка — переворачивается сама в себе**

```
1 2 3 → 3 2 1
```

→ Просто **меняешь местами левый и правый край**

---

## Картинка

```
←←←
1 2 3
→→→
```

→ Левая ↔ правая

---

# 9. Транспонирование не квадратной матрицы

## Представь: у тебя **таблица 2×3**

```
1 2 3
4 5 6
```

→ Хочешь **поменять строки и столбцы** → станет **3×2**

```
1 4
2 5
3 6
```

---

## Как?

> **Новая таблица**:
> - `новая[i][j] = старая[j][i]`

→ Но **нужна новая память**, потому что размеры разные

---

## Картинка

```
1 2 3     →     1 4
4 5 6           2 5
                3 6
```

---

# 10. Сумма подматрицы (финансовый отчёт)

## Представь: у тебя **отчёт по продажам**

```
10 20 30
40 50 60
70 80 90
```

→ Хочешь узнать: **сколько заработали с [0,1] по [1,2]**?

```
   20 30
   50 60
```

→ Сумма = 160

---

## Как быстро?

> **Сделай "накопительную" таблицу** (префиксные суммы)

```
 0  0  0  0
 0 10 30 60
 0 50 100 160
 0 120 200 290
```

→ Тогда сумма от `(r1,c1)` до `(r2,c2)`:

```
= 160 - 30 - 50 + 10 = 160
```

---

## Формула

```
сумма = prefix[r2+1][c2+1] 
      - prefix[r2+1][c1] 
      - prefix[r1][c2+1] 
      + prefix[r1][c1]
```

---

# 11. Поворот на 180° и 270°

## Поворот на **180°** — как **два раза по 90°**

```
1 2 3     →     9 8 7
4 5 6     →     6 5 4
7 8 9     →     3 2 1
```

→ Или: **перевернуть по горизонтали + по вертикали**

---

## Поворот на **270° по часовой** = **90° против часовой**

```
1 2 3     →     3 6 9
4 5 6     →     2 5 8
7 8 9     →     1 4 7
```

→ Или: **транспонировать + перевернуть столбцы**

---

# 12. Ротация колец (циклический сдвиг слоёв)

## Представь: у тебя **квадратная рамка**, и ты **крутишь её по часовой стрелке**

```
1 2 3
4 5 6
7 8 9
```

→ Сдвигаем **внешнее кольцо на 1 вперёд**:

```
7 4 1
8 5 2
9 6 3
```

---

## Как?

> **Каждое кольцо** — как **список**:
- Внешнее: `1,2,3,6,9,8,7,4`
- Внутреннее: `5`

→ Сдвигаешь **весь список на k позиций**

---

## Картинка

```
1 → 2 → 3 → 6 → 9 → 8 → 7 → 4 → 1
```

→ Сдвиг на 1: `4,1,2,3,6,9,8,7`

---

# 13. Проверка симметрии матрицы

## Представь: у тебя **зеркало по диагонали**

```
1 2 3
2 4 5
3 5 6
```

→ `matrix[i][j] == matrix[j][i]` → **симметрична**

---

## Как проверить?

> Сравни **верхний треугольник** с **нижним**

→ Если все пары совпадают → **да**

---

# 14. Сжатие данных (RLE 2D)

## Представь: у тебя **картинка из повторяющихся пикселей**

```
1 1 1 2 2
1 1 1 2 2
3 3 4 4 4
```

→ Хочешь записать **короче**:

```
(1,3), (2,2)
(1,3), (2,2)
(3,2), (4,3)
```

---

## Как?

> Идёшь **по строкам**, как читаешь книгу  
→ Считаешь, **сколько раз подряд одно и то же число**

---

# 15. Замена диагоналей

## Представь: у тебя **квадрат**, и ты **меняешь главную и побочную диагональ**

```
1 2 3
4 5 6
7 8 9
```

→ Главная: `1,5,9`  
→ Побочная: `3,5,7`

→ После замены:

```
3 2 1
4 5 6
9 8 7
```

---

## Как?

> Просто **меняешь местами**:
- `matrix[i][i]` ↔ `matrix[i][n-1-i]`

---

# 16. Сумма строк и столбцов

## Представь: у тебя **таблица доходов**

```
10 20
30 40
```

→ Хочешь:
- Сумма строк: `[30, 70]`
- Сумма столбцов: `[40, 60]`

---

## Как?

> Две прогулки:
1. По строкам → суммируешь
2. По столбцам → суммируешь

---

# 17. Транспонирование без доп. памяти (in-place)

## Только для **квадратной матрицы**

```
1 2 3
4 5 6
7 8 9
```

→ Хочешь **поменять по диагонали**, не используя новую матрицу

---

## Как?

> Меняешь **верхний треугольник**:
- `i < j` → `swap(matrix[i][j], matrix[j][i])`

---

# 18. Поиск максимального элемента

## Представь: ищешь **самую большую конфету**

```
10 99 20
30 40 50
```

→ `99` на позиции `(0,1)`

---

## Как?

> Идёшь по всем → сравниваешь → запоминаешь

---

# 19. Подсчёт чётных и нечётных

```
1 2 3
4 5 6
```

→ Чётных: `2,4,6` → 3  
→ Нечётных: `1,3,5` → 3

---

## Как?

> Идёшь → проверяешь `% 2 == 0`

---

# 20. Сдвиг строк вправо (циклически)

```
1 2 3     →     3 1 2
4 5 6     →     6 4 5
```

→ Сдвиг на 1 вправо

---

## Как?

> Новая строка:  
> `новая[j] = старая[(j - k) % m]`

---

# 21. Сдвиг столбцов вниз

```
1 2 3     →     4 5 6
4 5 6     →     7 8 9
7 8 9     →     1 2 3
```

---

## Как?

> `новая[i][j] = старая[(i - k) % n][j]`

---

# 22. Замена отрицательных на 0

```
-1  2
 3 -4
```

→

```
0 2
3 0
```

---

## Как?

> Идёшь → если `< 0` → ставишь `0`

---

# 23. Умножение матрицы на число

```
1 2     × 3     →     3  6
3 4                   9 12
```

---

## Как?

> Каждый элемент × число

---

# 24. Сумма диагоналей

```
1 2 3
4 5 6
7 8 9
```

→ Главная: `1+5+9 = 15`  
→ Побочная: `3+5+7 = 15`

---

## Как?

> Главная: `i == j`  
> Побочная: `i + j == n-1`

---

# 25. Обратный обход матрицы

## Представь: читаешь книгу **с конца**

```
1 2 3
4 5 6
7 8 9
```

→ Обратный порядок: `9,8,7,6,5,4,3,2,1`

---

## Как?

> Идёшь с конца:
- строки: `n-1 → 0`
- столбцы: `m-1 → 0`

---
