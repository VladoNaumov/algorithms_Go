# Что такое интервал — суперпростое объяснение

**Интервал = отрезок времени или расстояния, внутри которого что-то находится.**

---

##  Пример 1. Магазин работает с 9:00 до 18:00

Рабочее время — это **интервал времени**.
Если магазин открыт **включая** 9:00 и **включая** 18:00, то записали бы:
**[9; 18]**
Если открыт с 9:00, но ровно в 18:00 закрытые двери — не включаем 18 →
**[9; 18)**
Если магазин открывается «после 9:00» (двери открываются в 9:01), то:
**(9; 18)**
---

##  Пример 2. Ограничение скорости: от 40 до 60 км/ч
Зона с ограничением — это интервал.
Если можно ехать **включительно** 40 и 60:
**[40; 60]**
Если 60 — уже нарушение →
**[40; 60)**
---

# 1. Слияние интервалов (Объединение встреч)

**Зачем:** убрать перекрытия, получить «чистое» расписание — чтобы видеть, когда реально занято.

**Идея:** если две встречи частично или полностью накладываются, объединяем их в один большой промежуток.

**Что делать, шаги:**

1. Упорядочить встречи по времени начала (сначала самые ранние).
2. Взять первую встречу как текущую «группу».
3. Идёшь по списку: если следующая встреча начинается раньше, чем закончилась текущая — объединяешь (берёшь начало текущей и максимум из двух окончаний). Если не накладывается — сохраняешь предыдущую и начинаешь новую группу.

**Пример:** есть [9:00–10:00], [9:30–11:00], [12:00–13:00] → после объединения: [9:00–11:00], [12:00–13:00].

---

# 2. Вставка интервала (Новая задача)

**Зачем:** добавить новую встречу и сразу получить корректное расписание.

**Идея:** найти место, вставить, и при необходимости объединить с соседями, чтобы не было накладок.

**Что делать, шаги:**

1. Поскольку расписание уже упорядочено по началу, определить, куда вставить новую (перед каким стартом она идёт).
2. Вставить её туда.
3. Посмотреть на соседние интервалы: если они накладываются на новую, объединить их (как в задаче 1). Может понадобиться объединение влево и вправо.

**Пример:** расписание [9–10], [12–13]; вставляем [10:30–12:30] → после вставки объединяем с [12–13] → [9–10], [10:30–13:00].

---

# 3. Непересекающиеся интервалы (Оптимизация)

**Зачем:** удалить минимальное число встреч, чтобы оставшиеся не пересекались — полезно, например, чтобы найти максимально возможное число встреч, которые можно провести.

**Идея:** выгоднее выбирать встречи, которые завершаются раньше — они дают больше пространства для следующих.

**Что делать, шаги:**

1. Отсортировать встречи по времени окончания (самые ранние окончания первыми).
2. По очереди брать встречу, если она не пересекается с уже выбранной (т.е. её начало ≥ конец последней выбранной).
3. Количество удалений = всего − выбранных.

**Пример:** [1–4], [2–3], [3–5] → сортируем по окончанию: [2–3], [1–4], [3–5]. Берём [2–3], затем [3–5] → оставляем 2, удаляем 1.

---

# 4. Пересечение интервалов (Общее время)

**Зачем:** узнать, когда оба ресурса/человека одновременно заняты или свободны.

**Идея:** смотреть на пары интервалов из двух списков и брать общую часть, если она есть.

**Что делать, шаги:**

1. Идёшь по обоим спискам одновременно (оба упорядочены по началу).
2. Для текущей пары интервалов берёшь максиму из началов и минимум из окончаний — это потенциальное пересечение.
3. Если начало ≤ конец — пересечение есть. Затем сдвигаешь указатель в том списке, где заканчивается интервал раньше.

**Пример:** у A [9–11], у B [10–12] → пересечение [10–11].

---

# 5. Интервалы планировщика (Ресурсы)

**Зачем:** понять, сколько комнат/ресурсов нужно, чтобы одновременно проводить все встречи.

**Идея:** каждое начало увеличивает количество занятых комнат, каждое окончание — уменьшает; нужно знать максимум.

**Что делать, шаги (два образа):**

* (1) События: развернуть каждый интервал в два события — «старт» и «финиш», отсортировать по времени (старт до финиша при равенстве). Пройти по событиям, прибавляя +1 на старте и −1 на финише; максимум счётчика — ответ.
* (2) Мысленно: каждую встречу ставишь в первую свободную комнату (если нет свободной — берёшь новую).

**Пример:** [9–10], [9:30–11], [10:30–12] → в 9:30 уже 2 встречи, максимум = 2 (потом снова 2 и т.п.).

---

# 6. Проверка на пересечение

**Зачем:** просто узнать, пересекаются ли два конкретных интервала.

**Идея:** два отрезка на прямой пересекаются, если начало одного ≤ конец другого и начало второго ≤ конец первого.

**Что делать, шаги:**

1. Сравнить: если начало первого ≤ конец второго И начало второго ≤ конец первого — значит пересекаются. Иначе — нет.

**Пример:** [9–10] и [10–11] — не пересекаются, если конец один равен началу другого и такое касание не считается перекрытием; зависит от соглашения.

---

# 7. Пересечение двух списков интервалов (все общие времена)

**Зачем:** получить полный список промежутков, когда оба ресурса работают или оба свободны.

**Идея:** похожа на №4, но возвращаем все кусочки, не только один.

**Что делать, шаги:**

1. Два отсортированных списка и два указателя.
2. Для каждой пары вычисляешь перекрытие, если есть — добавляешь в результат.
3. Затем сдвигаешь тот указатель, чей интервал кончается раньше (чтобы не пропустить дальнейшие пересечения).

**Пример:** A: [9–10],[11–12]; B: [9:30–11:30] → пересечения: [9:30–10],[11–11:30].

---

# 8. Минимальное количество стрел (Кампании)

**Зачем:** покрыть все интервалы одной точкой внутри каждого (например, минимальным числом событий попасть по всем задачам).

**Идея:** ставить «стрелы» в самых выгодных местах — обычно в конце интервала. Так одна точка может покрыть максимальное число интервалов, которые ещё не покрыты.

**Что делать, шаги:**

1. Отсортировать интервалы по окончанию (раньше заканчивающиеся первыми).
2. Берёшь окончание первой как место выстрела — оно покроет все интервалы, которые содержат эту точку.
3. Удаляешь/пропускаешь все покрытые интервалы и повторяешь.

**Пример:** интервалы [1–3],[2–5],[3–6] → ставишь стрелу в 3 — она попадает в все три.

---

# 9. Добавление интервалов (Начисление)

**Зачем:** суммировать значения, которые действуют на определённые периоды (например, бонусы, скидки, нагрузка в сервере).

**Идея:** вместо пролистывания каждого момента удобно учитывать изменения только в границах: когда интервал начинается — прибавляем, когда заканчивается — убираем; потом «собираем» накопленное по времени.

**Что делать, шаги:**

1. Для каждого интервала отмечаешь в его начале «+величина», в конце «−величина».
2. Сортируешь все эти метки по времени и идёшь по ним, аккумулируя сумму. На отрезках между метками сумма постоянна.
3. Получаешь набор отрезков с итоговыми суммами.

**Пример:** [9–11] даёт +5, [10–12] даёт +3 → итог: 9–10: +5; 10–11: +8; 11–12: +3.

---

# 10. Перезагрузка интервалов (Свободное время)

**Зачем:** найти времена, когда человек свободен, чтобы назначить встречи.

**Идея:** взять весь рабочий промежуток и «вычесть» из него занятые куски.

**Что делать, шаги:**

1. Сначала объединить все занятые интервалы (как в задаче 1).
2. Взять рабочий интервал (например, 9–17).
3. Между объединёнными занятиями находишь промежутки, которые не заняты — это свободное время. Также перед первым занятым и после последнего может быть свободное время.

**Пример:** рабочий день 9–17, занято [9:30–10:30],[12–13] → свободно: [9–9:30],[10:30–12],[13–17].

---

# 11. Конфликты в расписании (когда оба свободны)

**Зачем:** найти время для встречи двух людей — когда оба свободны одновременно.

**Идея:** из каждого расписания сначала вычислить свободные интервалы (см. №10), затем найти пересечения этих свободных интервалов (см. №7).

**Что делать, шаги:**

1. Для каждого человека получить список свободных интервалов (вычитание из рабочего дня).
2. Найти пересечение двух списков свободных интервалов по алгоритму двух указателей.

**Пример:** A свободен [9–10],[12–17]; B свободен [8–9:30],[13–15] → общий: [9–9:30] и [13–15].

---

# 12. Планирование встреч (вставить длительность D)

**Зачем:** проверить, можно ли вписать новую встречу заданной длительности в график.

**Идея:** найти «достаточно длинный» пробел между занятиями.

**Что делать, шаги:**

1. Объединить и отсортировать занятые интервалы.
2. Просмотреть пробелы между ними (и до/после рабочего времени) — если где-то длина пробела ≥ D, можно вставить встречу.
3. Можно вернуть первый подходящий пробел или все возможные.

**Пример:** пробел 10:30–11:00 и нужная длительность 20 минут → помещается.

---

# 13. Загруженность сервера (максимум одновременно)

**Зачем:** понять пиковую нагрузку — максимальное число пользователей одновременно онлайн.

**Идея:** аналогично задаче про комнаты — считать +1 при входе, −1 при выходе и смотреть на максимум.

**Что делать, шаги:**

1. Для каждой сессии берёшь событие «вошёл» и «вышел».
2. Сортируешь события по времени (вошёл перед вышел при равенстве).
3. Проходишь и поддерживаешь счётчик онлайн; максимум — ответ.

**Пример:** вход в 9:00, выход в 9:30; другой вошёл в 9:15 — в 9:15–9:30 одновременно 2 пользователя.

---

# 14. Календарь занятости (Summary)

**Зачем:** получить компактное представление всех занятых периодов — полезно для отчётов.

**Идея:** объединить пересекающиеся и прилегающие интервалы — получится минимальный набор непересекающихся отрезков, который полностью покрывает всё занятое время.

**Что делать, шаги:**

1. Как в №1 — отсортировать и объединить по необходимости.
2. Результат — список чистых, непересекающихся интервалов.

**Пример:** [9–10],[9:30–9:45],[11–12] → итог [9–10],[11–12].

---

# 15. Конфликты в бронировании

**Зачем:** быстро проверить, есть ли двойное бронирование одной комнаты.

**Идея:** если после сортировки какие-то смежные брони перекрываются — конфликт.

**Что делать, шаги:**

1. Отсортировать брони по началу.
2. Пройти по списку и сравнивать начало текущей с концом предыдущей.
3. Если начало < конец предыдущей — найден конфликт.

**Пример:** брони [9–10],[9:30–10:30] — конфликт, так как 9:30 < 10:00.

---
