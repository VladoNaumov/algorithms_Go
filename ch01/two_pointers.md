## 1.  Целевая сумма инвестиций (Two Sum Closest)

**Суть:**
Найти два числа в отсортированном массиве, сумма которых ближе всего к заданной цели.

**Когда применять:**
Когда массив **уже отсортирован** и нужно быстро найти пару чисел с суммой, близкой к целевому значению.

**Пошаговый алгоритм:**

1. Установи `L = 0`, `R = N-1`.
2. Вычисли `sum = A[L] + A[R]`.
3. Если `|sum - target|` меньше текущей лучшей разницы — запомни её.
4. Если `sum < target` — увеличь `L` (хотим сумму больше).
5. Если `sum > target` — уменьши `R` (хотим сумму меньше).
6. Повторяй, пока `L < R`.

```
| Шаг                                          | L | R | A[L] | A[R] | Сумма | Разница к 10 | Движение |
| -------------------------------------------- | - | - | ---- | ---- | ----- | ------------ | -------- |
| 1                                            | 0 | 4 | -5   | 8    | 3     | 7            | ↑L       |
| 2                                            | 1 | 4 | 1    | 8    | 9     | 1            | ↑L       |
| 3                                            | 2 | 4 | 3    | 8    | 11    | 1            | ↓R       |
| 4                                            | 2 | 3 | 3    | 6    | 9     | 1            | ↑L       |
| **Результат:** сумма ближе всего к цели (9). |   |   |      |      |       |              |          |
```

---

## 2. Квадраты отсортированных значений (Sorted Squares)

**Суть:**
Получить отсортированный массив квадратов чисел (вход может содержать отрицательные).

**Когда применять:**
Когда массив **отсортирован, но содержит отрицательные значения**, и требуется получить квадраты — *в порядке возрастания*.

**Пошаговый алгоритм:**

1. Установи `L=0`, `R=N-1`, `W=N-1`.
2. Сравни `|A[L]|` и `|A[R]|`.
3. Больший квадрат запиши в `Result[W]`.
4. Сдвинь `L` или `R` в зависимости от того, кто был больше.
5. Уменьши `W`.
6. Повторяй, пока `L ≤ R`.

```
| Шаг | L | R | W | |A[L]| | |A[R]| | A[L]^2 | A[R]^2 | Запись |
|-----|---|---|---|--------|--------|--------|--------|--------|
| 1   | 0 | 4 | 4 | 4      | 10     | 16     | 100    | R→3    |
| 2   | 0 | 3 | 3 | 4      | 3      | 16     | 9      | L→1    |
| 3   | 1 | 3 | 2 | 1      | 3      | 1      | 9      | R→2    |
| 4   | 1 | 2 | 1 | 1      | 0      | 1      | 0      | L→2    |
| 5   | 2 | 2 | 0 | 0      | 0      | 0      | 0      | —      |
```
**Результат:** `[0, 1, 9, 16, 100]`

---

## 3.  Удаление дубликатов (Remove Duplicates In-Place)

**Суть:**
Удалить повторяющиеся элементы из отсортированного массива, не используя дополнительную память.

**Когда применять:**
Когда массив **отсортирован** и нужно удалить дубликаты **на месте** (in-place).

**Пошаговый алгоритм:**

1. Установи `W = 1` (позиция записи следующего уникального).
2. Для каждого `R` от `1` до `N-1`:

    * Если `A[R] != A[W-1]`, присвой `A[W] = A[R]` и увеличь `W`.
3. Возврати `W` — новую длину массива.

```
| W                                              | R | A[R] | Проверка | Действие        |
| ---------------------------------------------- | - | ---- | -------- | --------------- |
| 1                                              | 1 | 2    | =2       | Пропуск         |
| 1                                              | 2 | 3    | ≠2       | Записать A[1]=3 |
| 2                                              | 3 | 3    | =3       | Пропуск         |
| 2                                              | 5 | 5    | ≠3       | Записать A[2]=5 |
| 3                                              | 6 | 6    | ≠5       | Записать A[3]=6 |
| **Результат:** `[2, 3, 5, 6]` (новая длина 4). |   |      |          |                 |
```
---

## 4. Захват воды (Trapping Rain Water)

**Суть:**
Вычислить, сколько воды удержится между столбиками.

**Когда применять:**
Когда нужно посчитать "объём между стенками" — классическая задача на геометрию и баланс двух сторон.

**Пошаговый алгоритм:**

1. Установи L=0, R=N-1, MaxL=0, MaxR=0, water=0.
2. Пока L < R:
   - Если H[L] < H[R]:
      - Если H[L] >= MaxL: MaxL = H[L].
      - Иначе: добавить (MaxL - H[L]) к water.
      - L++.
   - Иначе:
      - Если H[R] >= MaxR: MaxR = H[R].
      - Иначе: добавить (MaxR - H[R]) к water.
      - R--.

```

| L                             | R   | MaxL | MaxR | Сравнение | Вода (новая) | Σ Воды |
| ----------------------------- | --- | ---- | ---- | --------- | ------------ | ------ |
| 0                             | 11  | 0    | 1    | 0<1       | 0            | 0      |
| 1                             | 11  | 1    | 1    | 1=1       | 0            | 0      |
| 1                             | 10  | 1    | 2    | 1<2       | 1            | 1      |
| 2                             | 10  | 1    | 2    | 1<2       | 0            | 1      |
| 3                             | 9   | 2    | 2    | 2=2       | 1            | 2      |
| ...                           | ... | ...  | ...  | ...       | ...          | ...    |
| **Результат:** 6 единиц воды. |     |      |      |           |              |        |
```
---

## 5. Сортировка чёт/нечёт (Stable Partition by Parity)

**Суть:**
Разделить массив на чётные и нечётные, сохранив порядок элементов.

**Когда применять:**
Когда важен **порядок** элементов и требуется быстрая сегрегация.

**Пошаговый алгоритм:**

1. Создай `Result=[]`.
2. Пройди по массиву — добавь все чётные.
3. Пройди второй раз — добавь все нечётные.

```
| Этап                                   | Действие                      | Result               |
| -------------------------------------- | ----------------------------- | -------------------- |
| 1                                      | Собираем чётные → 2, 4, 30    | [2, 4, 30]           |
| 2                                      | Добавляем нечётные → 11, 7, 1 | [2, 4, 30, 11, 7, 1] |
| **Результат:** `[2, 4, 30, 11, 7, 1]`. |                               |                      |

```

---

## 6. Единственный сотрудник (Single Number)

**Идея:**
Используем XOR. Свойство XOR: `a ⊕ a = 0` и `a ⊕ 0 = a`.
Если все элементы, кроме одного, встречаются дважды, XOR всех элементов даст единственного.

```
| Параметр  | Значение                       |
| --------- | ------------------------------ |
| Подход    | XOR, побитовые операции        |
| Сложность | O(N)                           |
| Цель      | Найти элемент, который встречается один раз |
```

**Пример:**
Массив = `[2, 3, 2]`

```
| Шаг | Элемент | Текущий XOR | Объяснение            |
| --- | ------- | ----------- | --------------------- |
| 1   | 2       | 0 ⊕ 2 = 2   | Инициализация         |
| 2   | 3       | 2 ⊕ 3 = 1   | XOR с новым элементом |
| 3   | 2       | 1 ⊕ 2 = 3   | XOR с повтором        |

```
**Результат:** 3

---

## 7. Продукт конкурентов (Product of Array Except Self)

**Идея:**
Два прохода:

1. Префиксное произведение слева → `left[i] = product(nums[0..i-1])`
2. Постфиксное произведение справа → `right[i] = product(nums[i+1..n-1])`
3. Итог: `res[i] = left[i] * right[i]`

```
| Параметр  | Значение                       |
| --------- | ------------------------------ |
| Подход    | Массивы, Префикс/Постфикс     |
| Сложность | O(N)                           |
| Цель      | Найти для каждого элемента произведение остальных |
```

**Пример:**
Массив = `[1,2,3,4]`

```
| i | left | right | res = left*right |
| - | ---- | ----- | ---------------- |
| 0 | 1    | 24    | 24               |
| 1 | 1    | 12    | 12               |
| 2 | 2    | 4     | 8                |
| 3 | 6    | 1     | 6                |
```

**Результат:** `[24,12,8,6]`

---

## 8. Максимальная последовательная убыль цен (Max Consecutive Drops)

**Идея:**
Проходим по массиву и считаем длину серии убывающих цен.

```
| Параметр  | Значение                       |
| --------- | ------------------------------ |
| Подход    | Массивы, подсчёт серий        |
| Сложность | O(N)                           |
| Цель      | Найти максимальное количество дней падения |
```

**Пример:**
Цены = `[5, 4, 3, 4, 2, 1]`

```

| Шаг | Цена[i] | Сравнение с предыдущей | Счётчик серии | МаксСерия |
| --- | ------- | ---------------------- | ------------- | --------- |
| 1   | 5       | —                      | 1             | 1         |
| 2   | 4       | 4<5                    | 2             | 2         |
| 3   | 3       | 3<4                    | 3             | 3         |
| 4   | 4       | 4<3                    | 1             | 3         |
| 5   | 2       | 2<4                    | 2             | 3         |
| 6   | 1       | 1<2                    | 3             | 3         |

```

**Результат:** 3 (подряд: `[5,4,3]`)

---

## 9. Сдвиг неактивных пользователей (Move Zeroes)

**Идея:**
Два указателя: `W` для следующего места ненулевого, `R` для обхода массива.

```
| Параметр  | Значение                          |
| --------- | -------------------------------- |
| Подход    | Массивы, два указателя            |
| Сложность | O(N)                              |
| Цель      | Все нули в конец, порядок остальных сохраняем |
```

**Пример:**
Массив = `[0,1,0,3,12]`

```
| Шаг | W | R | A[R] | Действие          | Массив        |
| --- | - | - | ---- | ----------------- | ------------- |
| 1   | 0 | 0 | 0    | R++               | [0,1,0,3,12]  |
| 2   | 0 | 1 | 1    | A[W]=1, W++, R++  | [1,1,0,3,12]  |
| 3   | 1 | 2 | 0    | R++               | [1,1,0,3,12]  |
| 4   | 1 | 3 | 3    | A[W]=3, W++, R++  | [1,3,0,3,12]  |
| 5   | 2 | 4 | 12   | A[W]=12, W++, R++ | [1,3,12,3,12] |
```

**Результат:** `[1,3,12,0,0]`

---

## 10. Рейтинг популярности товара (Top 3 Frequent Elements)

**Идея:**
Считаем частоты с помощью хеш-таблицы, сортируем по частоте, берём топ-3.

```
| Параметр  | Значение                  |
| --------- | ------------------------ |
| Подход    | Хеш-таблицы, частотный анализ |
| Сложность | O(N + k log k), k = уникальные значения |
| Цель      | Три самых популярных оценки |
```

**Пример:**
Оценки = `[1,1,1,2,2,3]`

```
| Элемент | Частота |
| ------- | ------- |
| 1       | 3       |
| 2       | 2       |
| 3       | 1       |

```
**Результат:** `[1,2,3]`

---

## 11. Баланс транзакций (Minimum Accumulated Balance)

**Идея:**
Считаем префиксные суммы и ищем минимальную.

```
| Параметр  | Значение                     |
| --------- | ---------------------------- |
| Подход    | Префиксные суммы             |
| Сложность | O(N)                         |
| Цель      | День с минимальным балансом  |
```

**Пример:**
Транзакции = `[100, -150, 50, -20]`

```
| День | ПрефиксСумма |
| ---- | ------------ |
| 0    | 100          |
| 1    | -50          |
| 2    | 0            |
| 3    | -20          |

```
**Результат:** День 1 (`-50`)

---

## 12. Проверка контрольной суммы (ISBN-10)

**Идея:**
ISBN-10: сумма `(i * digit_i) % 11 == 0`

```
| Параметр  | Значение                |
| --------- | ---------------------- |
| Подход    | Арифметика, цикл       |
| Сложность | O(10)                  |
| Цель      | Проверка контрольной суммы ISBN-10 |
```

**Пример:**
ISBN = `"0306406152"`

Считаем: `1*0 + 2*3 + 3*0 + ... + 10*2 = 110`
`110 % 11 == 0` ok

**Результат:** корректно

---

## 13. Поиск пиковой нагрузки (Peak Element)

**Идея:**
Элемент больше соседей — локальный максимум. Можно использовать бинарный поиск.

```
| Параметр  | Значение                |
| --------- | ----------------------- |
| Подход    | Двоичный поиск / перебор |
| Сложность | O(log N) бинарный поиск  |
| Цель      | Найти пик нагрузки       |
```

**Пример:**
Массив = `[1,3,2,5,4]`

```
| Шаг | Элемент | Сравнение с соседями | Пик? |
| --- | ------- | -------------------- | ---- |
| 0   | 3       | 3>1 & 3>2            | ok   |
| 1   | 5       | 5>2 & 5>4            | ok   |

```
**Результат:** 3 или 5

---

## 14. Самая длинная серия побед/поражений

**Идея:**
Подсчёт серий одинаковых значений, хранение максимума.

```
| Параметр  | Значение                |
| --------- | ----------------------- |
| Подход    | Массивы, подсчёт серий  |
| Сложность | O(N)                    |
| Цель      | Длина самой длинной серии |
```

**Пример:**
Результаты = `[W,W,L,L,L,W]`

```
| Шаг | Результат | Серия | Макс |
| --- | --------- | ----- | ---- |
| 1   | W         | 1     | 1    |
| 2   | W         | 2     | 2    |
| 3   | L         | 1     | 2    |
| 4   | L         | 2     | 2    |
| 5   | L         | 3     | 3    |
| 6   | W         | 1     | 3    |
```
**Результат:** 3

---

## 15. Проверка уникальности ID

**Идея:**
Используем множество (HashSet), если встречаем повтор — False.

```
| Параметр  | Значение          |
| --------- | ----------------- |
| Подход    | Множества / Хеш   |
| Сложность | O(N)              |
| Цель      | Проверить дубликаты |
```

**Пример:**
IDs = `[101, 102, 103, 101]`

```
| ID  | Множество     | Дубликат? |
| --- | ------------- | --------- |
| 101 | {101}         | —         |
| 102 | {101,102}     | —         |
| 103 | {101,102,103} | —         |
| 101 | {101,102,103} | ok        |

```
**Результат:** массив содержит дубликаты

---

